<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turducken - Formal Methods in Prolog</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            font-size: 1.8rem;
            color: var(--accent-blue);
        }
        
        h1 span {
            color: var(--text-secondary);
            font-weight: normal;
            font-size: 1rem;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
        }
        
        .status-indicator.error {
            background: var(--accent-red);
        }
        
        .status-indicator.success {
            background: var(--accent-green);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            height: auto;
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .spec-banner {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .spec-title {
            color: var(--accent-blue);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .spec-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .spec-file {
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-family: monospace;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .panel-body {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .tabs {
            display: flex;
            gap: 4px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        
        .tab {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: var(--accent-blue);
            color: white;
        }

        
        textarea, input[type="text"] {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .editor {
            flex: 1;
            min-height: 200px;
            resize: none;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }
        
        .btn-primary:hover {
            background: #4393e6;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--border-color);
        }
        
        .btn-success {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .output {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.85rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .output.success {
            border-color: var(--accent-green);
        }
        
        .output.error {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 12px;
            padding-right: 8px;
        }
        
        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .message.user {
            background: var(--bg-tertiary);
            margin-left: 40px;
        }
        
        .message.assistant {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            margin-right: 40px;
        }
        
        .message-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .chat-input-area {
            flex-shrink: 0;
        }
        
        .chat-input-area textarea {
            min-height: 80px;
        }
        
        .mermaid-output {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        
        .mermaid-output .mermaid {
            min-width: auto;
        }
        
        .mermaid-output svg {
            min-width: auto;
            min-height: auto;
            max-width: 100%;
        }
        
        .property-check {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .property-check input {
            flex: 1;
        }
        
        .check-result {
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .check-result.satisfied {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .check-result.unsatisfied {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .tab-content {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        pre code {
            display: block;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            overflow-x: auto;
        }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .help-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 8px;
        }

        .terminal-output {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            min-height: 200px;
            max-height: 280px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .terminal-line {
            margin-bottom: 6px;
            white-space: pre-wrap;
        }

        .terminal-prompt {
            color: var(--accent-blue);
        }

        .terminal-input {
            display: inline-block;
            min-width: 60%;
            outline: none;
            color: var(--text-primary);
        }
        
        .examples {
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .example-btn {
            font-size: 0.8rem;
            padding: 4px 8px;
            margin-right: 4px;
            margin-bottom: 4px;
        }
        
        .viz-section {
            margin-bottom: 16px;
        }

        .viz-description {
            margin: 0 0 10px 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Turducken <span>Formal Methods in Prolog</span></h1>
            <div class="status">
                <select id="providerSelect" class="btn btn-secondary" style="padding: 4px 8px; font-size: 0.85rem;" onchange="switchProvider()">
                    <option value="openai">ChatGPT</option>
                    <option value="anthropic">Claude</option>
                </select>
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Ready</span>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Spec & Visualization -->
            <div class="panel">
                <div id="specBanner" class="spec-banner">
                    <div class="spec-title">No spec loaded</div>
                    <div class="spec-desc">Load a Prolog specification to see system details.</div>
                    <div class="spec-file"></div>
                </div>
                <!-- Add new tab button in the tabs div -->
                <div class="tabs">
                    <button class="tab" onclick="switchTab('states')">üß≠ States</button>
                    <button class="tab" onclick="switchTab('simulation')">üìà Simulation</button>
                    <button class="tab" onclick="switchTab('docs')">üìñ Docs</button>
                    <button class="tab" onclick="switchTab('check')">‚úì Check</button>
                    <button class="tab active" onclick="switchTab('spec')">üìù Prolog</button>
                    <button class="tab" onclick="switchTab('prompt')">üß≠ System Prompt</button>
                    <button class="tab" onclick="switchTab('query')">üñ• Terminal</button>
                </div>
                
                <!-- States Tab -->
                <div id="tab-states" class="tab-content">
                    <div class="panel-body">
                        <div class="viz-section">
                            <div id="statesSequenceOutput" class="mermaid-output">
                                <div style="color: var(--text-secondary); text-align: center;">
                                    Load a spec to visualize the sequence
                                </div>
                            </div>
                        </div>
                        <div class="viz-section">
                            <div id="statesMachineOutput" class="mermaid-output">
                                <div style="color: var(--text-secondary); text-align: center;">
                                    Load a spec to visualize state machines
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Simulation Tab -->
                <div id="tab-simulation" class="tab-content">
                    <div class="panel-body">
                        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 12px; flex-wrap: wrap;">
                            <label for="simulationSteps" style="color: var(--text-secondary); font-size: 0.85rem;">Steps</label>
                            <input type="number" id="simulationSteps" value="1000" min="1" style="width: 120px;">
                            <button class="btn btn-secondary" onclick="renderSimulation()">Run Simulation</button>
                        </div>
                        <div class="viz-section">
                            <h4 style="margin: 0 0 8px 0; color: var(--text-primary);">Line Chart</h4>
                            <div id="simulationLineOutput" class="mermaid-output">
                                <div style="color: var(--text-secondary); text-align: center;">
                                    Load a spec to visualize line charts
                                </div>
                            </div>
                        </div>
                        <div class="viz-section">
                            <h4 style="margin: 0 0 8px 0; color: var(--text-primary);">Pie Chart</h4>
                            <div id="simulationPieOutput" class="mermaid-output">
                                <div style="color: var(--text-secondary); text-align: center;">
                                    Load a spec to visualize pie charts
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Prolog Spec Tab -->
                <div id="tab-spec" class="tab-content active">
                    <div class="panel-body">
                        <textarea id="specEditor" class="editor" placeholder="% Enter your Prolog specification here...

% Example state machine:
state(idle, [waiting]).
state(busy, [processing]).
initial(idle).
transition(idle, start, busy).
transition(busy, done, idle).
"></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="applySpec()">Apply Spec</button>
                            <button class="btn btn-secondary" onclick="resetEngine()">Reset</button>
                        </div>
                        <div class="examples">
                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Examples: </span>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('mutex')">Mutex</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('channel')">Channel</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('sequence')">Sequence</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('yahalom')">Yahalom</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('needham_schroeder')">Needham-Schroeder</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('kerberos')">Kerberos</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('bread_company')">Bread Company</button>
                        </div>
                    </div>
                </div>
                
                <!-- System Prompt Tab -->
                <div id="tab-prompt" class="tab-content">
                    <div class="panel-body" style="overflow-y: auto; min-height: 0; flex: 1;">
                        <h4 style="margin: 0 0 8px 0; color: var(--text-secondary);">System Prompt</h4>
                        <pre id="systemPromptText" style="white-space: pre-wrap; margin: 0 0 16px 0; color: var(--text-primary);"></pre>
                        <h4 style="margin: 0 0 8px 0; color: var(--text-secondary);">User Prompt (preview)</h4>
                        <pre id="userPromptText" style="white-space: pre-wrap; margin: 0; color: var(--text-primary);"></pre>
                    </div>
                </div>
                
                <!-- Query Tab -->
                <div id="tab-query" class="tab-content">
                    <div class="panel-body">
                        <div id="terminalHelp" class="help-text"></div>
                        <div id="queryOutput" class="terminal-output" tabindex="0"></div>
                    </div>
                </div>
                
                <!-- Check Tab -->
                <div id="tab-check" class="tab-content">
                    <div class="panel-body">
                        <h4 style="margin: 0 0 12px 0; color: var(--text-primary);">CTL Properties</h4>
                        <div id="propertyList" style="margin-bottom: 16px;">
                            <div style="color: var(--text-secondary);">Load a spec to see defined properties</div>
                        </div>
                        
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary);">Custom Check</h4>
                        <form class="property-check" onsubmit="event.preventDefault(); checkProperty();">
                            <input type="text" id="propertyInput" placeholder="CTL formula">
                            <button id="checkButton" class="btn btn-primary" type="submit">Check</button>
                        </form>
                        <div id="checkHint" class="help-text"></div>
                        <div class="help-text">
                            CTL operators: <code>ef</code>, <code>af</code>, <code>eg</code>, <code>ag</code>, <code>ex</code>, <code>ax</code>, <code>eu</code>, <code>au</code><br>
                            Combinators: <code>atom(p)</code>, <code>not(œÜ)</code>, <code>and(œÜ,œà)</code>, <code>or(œÜ,œà)</code>
                        </div>
                        <div id="checkResult"></div>
                    </div>
                </div>
                
                <!-- Docs Tab -->
                <div id="tab-docs" class="tab-content">
                    <div class="panel-body" style="overflow-y: auto; min-height: 0; flex: 1;">
                        <div id="docsContent" style="overflow-y: auto; height: 100%;">
                            <div style="color: var(--text-secondary);">Load a spec to see documentation</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Chat Only -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">üí¨ Chat</span>
                    <button class="btn btn-secondary" onclick="clearChat()" style="padding: 4px 12px;">Clear</button>
                </div>
                <div class="panel-body chat-container">
                    <div id="chatMessages" class="chat-messages">
                        <div class="message assistant">
                            <div class="message-label">Turducken</div>
                            Describe the system you want to model, and I'll generate a Prolog specification. 
                            You can ask me to model state machines, protocols, processes, or any system with temporal properties.
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <textarea id="chatInput" rows="3" placeholder="Describe your system or ask a question..."></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="sendChat()">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        // Initialize Mermaid with dark theme
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                darkMode: true,
                background: '#0d1117',
                primaryColor: '#58a6ff',
                primaryTextColor: '#e6edf3',
                primaryBorderColor: '#30363d',
                lineColor: '#8b949e',
                secondaryColor: '#21262d',
                tertiaryColor: '#161b22'
            }
        });

        const actorDescriptions = new Map();
        const transitionProbabilities = new Map();
        const transitionProbabilitiesByLabel = new Map();
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            if (tabName === 'prompt') {
                loadPromptPreview();
            } else if (tabName === 'states') {
                renderStates();
            } else if (tabName === 'simulation') {
                renderSimulation();
            } else if (tabName === 'query') {
                focusTerminalInput(document.getElementById('queryOutput'));
            }
        }
        
        // API calls
        // Regular apply - no auto-fix
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                    loadDocs();  // Add this line
                    loadPromptPreview();
                    updateTerminalHelp();
                    updateCheckAvailability();
                    updateTransitionProbabilities(source);
                    if (document.getElementById('tab-states').classList.contains('active')) {
                        renderStates();
                    }
                    if (document.getElementById('tab-simulation').classList.contains('active')) {
                        renderSimulation();
                    }
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        async function resetEngine() {
            try {
                await fetch('/api/reset', { method: 'POST' });
                setStatus('success', 'Reset complete');
                updateTerminalHelp();
                updateCheckAvailability();
                switchTab('spec');
            } catch (err) {
                setStatus('error', 'Reset failed');
            }
        }
        
        async function runQuery() {
            const output = document.getElementById('queryOutput');
            const rawQuery = getTerminalInput(output);
            const trimmedQuery = rawQuery.trim();
            const command = trimmedQuery.replace(/\.\s*$/, '');
            
            if (!command) {
                appendTerminalLine(output, 'Enter a query', 'var(--accent-yellow)');
                return;
            }

            removeTrailingPrompt(output);
            appendTerminalLine(output, `| ?- ${rawQuery.trim()}`, 'var(--accent-blue)');

            if (command === 'ls' || command === 'dir') {
                try {
                    const resp = await fetch('/api/spec');
                    const data = await resp.json();
                    const source = (data && data.source) ? data.source : '';
                    const listing = parseFactsAndRulesFromSource(source);
                    appendTerminalLine(output, listing || 'no facts or rules', 'var(--text-primary)');
                    appendPromptLine(output);
                    return;
                } catch (err) {
                    appendTerminalLine(output, `Failed: ${err.message}`, 'var(--accent-red)');
                }
                appendPromptLine(output);
                return;
            }

            if (command === 'lsq' || command === 'lsq.') {
                appendTerminalLine(output, 'Use `ls.` to list facts and rules.', 'var(--accent-yellow)');
                appendPromptLine(output);
                return;
            }

            const queryToSend = command.endsWith('.') ? command : `${command}.`;
            
            try {
                const resp = await fetch('/api/query', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query: queryToSend })
                });
                const data = await resp.json();

                if (data.success) {
                    if (Array.isArray(data.bindings) && data.bindings.length > 0) {
                        const formatted = formatBindings(data.bindings);
                        appendTerminalLine(output, formatted, 'var(--text-primary)');
                    } else {
                        appendTerminalLine(output, data.result, 'var(--text-primary)');
                    }
                } else {
                    appendTerminalLine(output, `Error: ${data.error}`, 'var(--accent-red)');
                }
            } catch (err) {
                appendTerminalLine(output, `Failed: ${err.message}`, 'var(--accent-red)');
            }

            appendPromptLine(output);
        }

        function formatPredicateList(predicates) {
            const entries = predicates
                .map(p => `${p.name}/${p.arity}`)
                .sort((a, b) => a.localeCompare(b));
            if (entries.length === 0) {
                return '';
            }
            const maxLen = entries.reduce((max, item) => Math.max(max, item.length), 0);
            const colWidth = Math.min(Math.max(maxLen + 2, 12), 32);
            const columns = Math.max(1, Math.floor(80 / colWidth));
            let lines = [];
            for (let i = 0; i < entries.length; i += columns) {
                const row = entries.slice(i, i + columns)
                    .map(item => item.padEnd(colWidth))
                    .join('');
                lines.push(row.trimEnd());
            }
            return lines.join('\n');
        }

        function formatBindings(bindings) {
            const lines = [];
            bindings.forEach((row, idx) => {
                const keys = Object.keys(row).sort((a, b) => a.localeCompare(b));
                if (keys.length === 0) {
                    lines.push('true');
                    return;
                }
                const parts = keys.map(key => `${key} = ${row[key]}`);
                lines.push(parts.join(', '));
            });
            return lines.join('\n');
        }

        function parseFactsAndRulesFromSource(source) {
            if (!source) {
                return '';
            }
            const lines = source.split('\n').map(line => {
                const idx = line.indexOf('%');
                return idx >= 0 ? line.slice(0, idx) : line;
            });
            const joined = lines.join('\n');
            const clauses = joined.split('.');
            const facts = [];
            const rules = [];
            for (const clause of clauses) {
                const trimmed = clause.trim();
                if (!trimmed) {
                    continue;
                }
                if (trimmed.includes(':-')) {
                    rules.push(`${trimmed}.`);
                } else {
                    facts.push(`${trimmed}.`);
                }
            }
            const sections = [];
            if (facts.length > 0) {
                sections.push('[facts]');
                sections.push(...facts);
            }
            if (rules.length > 0) {
                sections.push('[rules]');
                sections.push(...rules);
            }
            if (sections.length === 0) {
                return '';
            }
            return sections.join('\n');
        }

        function appendTerminalLine(output, text, color) {
            if (!output) {
                return;
            }
            const line = document.createElement('div');
            line.className = 'terminal-line';
            if (color) {
                line.style.color = color;
            }
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function scrollTerminalToBottom() {
            const output = document.getElementById('queryOutput');
            if (output) {
                output.scrollTop = output.scrollHeight;
            }
        }

        function appendPromptLine(output) {
            if (!output) {
                return;
            }
            const line = document.createElement('div');
            line.className = 'terminal-line';
            line.dataset.prompt = 'true';
            const prompt = document.createElement('span');
            prompt.className = 'terminal-prompt';
            prompt.textContent = '| ?-';
            line.appendChild(prompt);
            const input = document.createElement('span');
            input.className = 'terminal-input';
            input.contentEditable = 'true';
            input.spellcheck = false;
            input.autocapitalize = 'off';
            input.autocomplete = 'off';
            input.autocorrect = 'off';
            input.style.marginLeft = '6px';
            line.appendChild(input);
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            bindTerminalInput(input);
            focusTerminalInput(output);
        }

        function removeTrailingPrompt(output) {
            if (!output) {
                return;
            }
            const last = output.lastElementChild;
            if (last && last.dataset && last.dataset.prompt === 'true') {
                last.remove();
            }
        }

        function focusTerminalInput(output) {
            if (!output) {
                return;
            }
            let input = output.querySelector('.terminal-input');
            if (!input) {
                appendPromptLine(output);
                input = output.querySelector('.terminal-input');
            }
            if (input) {
                input.focus();
                const range = document.createRange();
                range.selectNodeContents(input);
                range.collapse(false);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
            output.scrollTop = output.scrollHeight;
        }

        function getTerminalInput(output) {
            if (!output) {
                return '';
            }
            const input = output.querySelector('.terminal-input');
            if (!input) {
                return '';
            }
            return input.textContent.trim();
        }

        function bindTerminalInput(input) {
            if (!input) {
                return;
            }
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    runQuery();
                    return;
                }
                if (e.key === 'Backspace') {
                    const sel = window.getSelection();
                    if (!sel || sel.rangeCount === 0) {
                        return;
                    }
                    const range = sel.getRangeAt(0);
                    if (range.collapsed && range.startOffset === 0 && input.textContent.length === 0) {
                        e.preventDefault();
                    }
                }
            });
            input.addEventListener('input', () => {
                scrollTerminalToBottom();
            });
        }
        
        async function checkProperty() {
            let property = document.getElementById('propertyInput').value;
            const resultDiv = document.getElementById('checkResult');
            
            if (!property) {
                resultDiv.innerHTML = '';
                return;
            }
            property = property.trim().replace(/\.\s*$/, '');
            
            try {
                const resp = await fetch('/api/check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ property })
                });
                const data = await resp.json();
                
                if (data.success) {
                    const ctlMath = ctlToMath(property);
                    const mathLine = (ctlMath && ctlMath !== property)
                        ? `<div style="font-size: 0.85rem; color: var(--text-primary); margin-top: 6px; font-family: monospace;">${escapeHtml(ctlMath)}</div>`
                        : '';
                    resultDiv.innerHTML = `<div class="check-result ${data.satisfied ? 'satisfied' : 'unsatisfied'}">
                        ${data.satisfied ? '‚úì Property SATISFIED' : '‚úó Property NOT satisfied'}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--accent-purple); margin-top: 6px; font-family: monospace;">${escapeHtml(property)}</div>
                    ${mathLine}`;
                } else {
                    resultDiv.innerHTML = `<div class="check-result unsatisfied">Error: ${data.error}</div>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<div class="check-result unsatisfied">Failed: ${err.message}</div>`;
            }
        }
        
        function setProperty(prop) {
            document.getElementById('propertyInput').value = prop;
        }
        
        async function sendChat() {
            const input = document.getElementById('chatInput');
            const messages = document.getElementById('chatMessages');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            messages.innerHTML += `<div class="message user">
                <div class="message-label">You</div>
                ${escapeHtml(message)}
            </div>`;
            
            input.value = '';
            messages.scrollTop = messages.scrollHeight;
            
            // Show loading
            const loadingId = 'loading-' + Date.now();
            messages.innerHTML += `<div id="${loadingId}" class="message assistant">
                <div class="message-label">Turducken</div>
                <div class="loading"></div> Thinking...
            </div>`;
            messages.scrollTop = messages.scrollHeight;
            
            try {
                const resp = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message,
                        context: document.getElementById('specEditor').value
                    })
                });
                const data = await resp.json();
                
                // Remove loading message
                document.getElementById(loadingId)?.remove();
                
                if (data.success) {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Turducken</div>
                        ${formatResponse(data.response)}
                    </div>`;
                    
                    // If there's Prolog code, auto-populate the editor
                    if (data.prolog) {
                        document.getElementById('specEditor').value = data.prolog;
                        
                        // Add apply button
                        messages.innerHTML += `<div class="message assistant" style="padding: 8px 12px;">
                            <button class="btn btn-success" onclick="applyAndVisualize()">
                                ‚úì Apply Spec & Visualize
                            </button>
                            <span style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 8px;">
                                Prolog populated in editor
                            </span>
                        </div>`;
                    }
                } else {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Error</div>
                        ${data.error}
                    </div>`;
                }
            } catch (err) {
                document.getElementById(loadingId)?.remove();
                messages.innerHTML += `<div class="message assistant">
                    <div class="message-label">Error</div>
                    ${err.message}
                </div>`;
            }
            
            messages.scrollTop = messages.scrollHeight;
        }
        
        async function applyAndVisualize() {
            await applySpec();
            switchTab('states');
            await renderStates();
        }

        function clearChat() {
            document.getElementById('chatMessages').innerHTML = `<div class="message assistant">
                <div class="message-label">Turducken</div>
                Describe the system you want to model, and I'll generate a Prolog specification.
            </div>`;
        }
        
        async function renderStates() {
            const descriptions = await loadVizDescriptions();
            await visualize('sequence', 'statesSequenceOutput', {
                title: 'Sequence',
                description: descriptions.sequence
            });
            await visualize('statemachine', 'statesMachineOutput', {
                title: 'State Machines',
                description: descriptions.state
            });
        }

        async function renderSimulation() {
            const lineOutput = document.getElementById('simulationLineOutput');
            const pieOutput = document.getElementById('simulationPieOutput');
            const stepsInput = document.getElementById('simulationSteps');
            const steps = parseInt(stepsInput?.value || '1000', 10);
            const safeSteps = Number.isFinite(steps) && steps > 0 ? steps : 1000;
            if (stepsInput) {
                stepsInput.value = safeSteps;
            }

            if (lineOutput) {
                lineOutput.innerHTML = '<div class="loading"></div>';
            }
            if (pieOutput) {
                pieOutput.innerHTML = '<div class="loading"></div>';
            }

            try {
                const resp = await fetch(`/api/simulate?steps=${safeSteps}`);
                const data = await resp.json();
                const events = Array.isArray(data.timeline) ? data.timeline : [];

                if (!events.length) {
                    if (lineOutput) {
                        lineOutput.innerHTML = '<div style="color: var(--text-secondary);">No simulation events available. Load a spec first.</div>';
                    }
                    if (pieOutput) {
                        pieOutput.innerHTML = '<div style="color: var(--text-secondary);">No simulation events available. Load a spec first.</div>';
                    }
                    return;
                }

                const extractActor = (state) => {
                    if (!state) return 'unknown';
                    const idx = state.indexOf('_');
                    return idx > 0 ? state.slice(0, idx) : state;
                };

                const bySrc = (data.bySrc && Object.keys(data.bySrc).length > 0)
                    ? data.bySrc
                    : events.reduce((acc, evt) => {
                        const actor = extractActor(evt.from);
                        acc[actor] = (acc[actor] || 0) + 1;
                        return acc;
                    }, {});

                const pieSlices = Object.entries(bySrc)
                    .map(([label, value]) => `    "${label}" : ${value}`)
                    .join('\n');
                if (pieOutput) {
                    pieOutput.innerHTML = `<pre class="mermaid">pie title Messages By Sender\n${pieSlices}</pre>`;
                }

                const ordered = events.map(evt => ({
                    seq: (typeof evt.step === 'number' && !Number.isNaN(evt.step)) ? evt.step + 1 : 0,
                    from: extractActor(evt.from)
                })).sort((a, b) => a.seq - b.seq);

                const senders = new Set();
                ordered.forEach(m => senders.add(m.from));

                const runningCounts = {};
                const cumulativeBySender = new Map();
                for (const sender of senders) {
                    runningCounts[sender] = 0;
                    cumulativeBySender.set(sender, []);
                }

                const xValues = [];
                ordered.forEach(evt => {
                    runningCounts[evt.from]++;
                    xValues.push(evt.seq);
                    for (const [sender, arr] of cumulativeBySender) {
                        arr.push(runningCounts[sender]);
                    }
                });

                const maxY = Math.max(...Object.values(runningCounts)) + 2;
                const xAxis = xValues.map(x => `"${x}"`).join(', ');

                let code = `xychart-beta
    title "Messages Over Simulation"
    x-axis "Step" [${xAxis}]
    y-axis "Count" 0 --> ${maxY}`;

                for (const [sender, values] of cumulativeBySender) {
                    code += `\n    line [${values.join(', ')}]`;
                }

                if (lineOutput) {
                    const series = Array.from(cumulativeBySender.keys()).map(name => ({ name }));
                    const legendHtml = generateLineLegend({ series });
                    lineOutput.innerHTML = `<pre class="mermaid">${code}</pre>${legendHtml}`;
                }

                await mermaid.run();
            } catch (err) {
                if (lineOutput) {
                    lineOutput.innerHTML = `<div style="color: var(--accent-red);">Error: ${err.message}</div>`;
                }
                if (pieOutput) {
                    pieOutput.innerHTML = `<div style="color: var(--accent-red);">Error: ${err.message}</div>`;
                }
            }
        }

        async function loadVizDescriptions() {
            try {
                const resp = await fetch('/api/docs');
                const data = await resp.json();
                const docs = (data.success && data.docs) ? data.docs : [];
                const docMap = new Map(docs.map(doc => [doc.topic, doc.content]));
                const defaultSequence = 'An authentication system represented as CSP with checked CTL properties.';
                const baseSequence = docMap.get('viz_sequence') || docMap.get('description') || docMap.get('overview') || defaultSequence;
                const items = [baseSequence];
                const ctlSuffix = 'This is the CSP actors which can have CTL properties.';
                if (!baseSequence.includes('CTL')) {
                    items.push(ctlSuffix);
                }
                const varsText = docMap.get('vars') || '';
                if (varsText) {
                    const varsItems = varsText
                        .split(';')
                        .map(item => item.trim())
                        .filter(Boolean);
                    items.push(...varsItems);
                }
                const sequenceText = items.length > 0
                    ? `- ${items.join('\n- ')}`
                    : '';
                const stateText = docMap.get('viz_statemachine') || '';
                return { sequence: sequenceText, state: stateText };
            } catch (_err) {
                return { sequence: '', state: '' };
            }
        }

        async function visualize(type, outputId = 'vizOutput', opts = {}) {
            const output = document.getElementById(outputId);
            if (!output) {
                return;
            }
            output.innerHTML = '<div class="loading"></div>';
            
            try {
                // Pie and Line show message traffic (from message/4 facts)
                if (type === 'pie' || type === 'line') {
                    const resp = await fetch('/api/visualize?type=sequence');
                    const data = await resp.json();
                    const messages = (data.sequence && data.sequence.messages) ? data.sequence.messages : [];
                    
                    if (messages.length === 0) {
                        output.innerHTML = '<div style="color: var(--text-secondary);">No messages to chart. Add message/4 facts.</div>';
                        return;
                    }
                    
                    if (type === 'pie') {
                        const counts = {};
                        messages.forEach(m => {
                            const key = m.from || 'unknown';
                            counts[key] = (counts[key] || 0) + 1;
                        });
                        
                        const slices = Object.entries(counts)
                            .map(([label, value]) => `    "${label}" : ${value}`)
                            .join('\n');
                        
                        output.innerHTML = `<pre class="mermaid">pie title Messages By Sender\n${slices}</pre>`;
                        await mermaid.run();
                        return;
                    } else if (type === 'line') {
                        const ordered = messages.map((m, idx) => ({
                            seq: (typeof m.seq === 'number' && !Number.isNaN(m.seq)) ? m.seq : idx + 1,
                            from: m.from || 'unknown'
                        })).sort((a, b) => a.seq - b.seq);
                        
                        const senders = new Set();
                        ordered.forEach(m => senders.add(m.from));
                        
                        const runningCounts = {};
                        const cumulativeBySender = new Map();
                        for (const sender of senders) {
                            runningCounts[sender] = 0;
                            cumulativeBySender.set(sender, []);
                        }
                        
                        const xValues = [];
                        ordered.forEach(evt => {
                            runningCounts[evt.from]++;
                            xValues.push(evt.seq);
                            
                            for (const [sender, arr] of cumulativeBySender) {
                                arr.push(runningCounts[sender]);
                            }
                        });
                        
                        if (xValues.length === 0) {
                            output.innerHTML = '<div style="color: var(--text-secondary);">No message data.</div>';
                            return;
                        }
                        
                        const maxPoints = 200;
                        let sampledX = xValues;
                        let sampledSeries = cumulativeBySender;
                        
                        if (xValues.length > maxPoints) {
                            const stride = Math.ceil(xValues.length / maxPoints);
                            const sampleIdx = [];
                            for (let i = 0; i < xValues.length; i += stride) {
                                sampleIdx.push(i);
                            }
                            
                            sampledX = sampleIdx.map(i => xValues[i]);
                            sampledSeries = new Map();
                            for (const [sender, values] of cumulativeBySender) {
                                sampledSeries.set(sender, sampleIdx.map(i => values[i]));
                            }
                        }
                        
                        const maxY = Math.max(...Object.values(runningCounts)) + 2;
                        const xAxis = sampledX.map(x => `"${x}"`).join(', ');
                        
                        let code = `xychart-beta
    title "Messages Over Sequence"
    x-axis "Seq" [${xAxis}]
    y-axis "Count" 0 --> ${maxY}`;
                        
                        for (const [sender, values] of sampledSeries) {
                            code += `\n    line [${values.join(', ')}]`;
                        }
                        
                        const series = Array.from(sampledSeries.keys()).map(name => ({ name }));
                        const legendHtml = generateLineLegend({ series });
                        output.innerHTML = `<pre class="mermaid">${code}</pre>${legendHtml}`;
                        try {
                            await mermaid.run();
                        } catch (mermaidErr) {
                            console.error('Mermaid error:', mermaidErr);
                            output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem;">${code}</pre>`;
                        }
                        return;
                    }
                }
                
                // State machine and sequence use Prolog visualization data
                const resp = await fetch(`/api/visualize?type=${type}`);
                const data = await resp.json();
                
                let mermaidCode = '';
                let noDataMessage = '';
                
                switch (type) {
                    case 'statemachine':
                        if (data.stateMachine && data.stateMachine.transitions) {
                            const actorMachines = groupTransitionsByActor(data.stateMachine);
                            if (Object.keys(actorMachines).length > 1) {
                                output.innerHTML = generateActorPanes(actorMachines);
                                await mermaid.run();
                                return;
                            }
                        }
                        mermaidCode = generateStateMachineMermaid(data.stateMachine);
                        break;
                    case 'sequence':
                        mermaidCode = generateSequenceMermaid(data.sequence);
                        if (!mermaidCode) {
                            noDataMessage = 'No sequence messages found. Add lifeline/1 and message/4 facts to your spec.';
                        }
                        break;
                }
                
                if (mermaidCode) {
                    const titleHtml = opts.title
                        ? `<div style="margin: 0 0 8px 0; color: var(--accent-blue); font-weight: 600;">${escapeHtml(opts.title)}</div>`
                        : '';
                    const descHtml = opts.description
                        ? `<div class="viz-description" style="margin: 0 0 10px 0;">${formatDescription(opts.description)}</div>`
                        : '';
                    output.innerHTML = `${titleHtml}${descHtml}<pre class="mermaid">${mermaidCode}</pre>`;
                    try {
                        await mermaid.run();
                    } catch (mermaidErr) {
                        console.error('Mermaid error:', mermaidErr);
                        output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem;">${mermaidCode}</pre>`;
                    }
                } else {
                    output.innerHTML = `<div style="color: var(--text-secondary);">${noDataMessage || 'No data to visualize. Load a specification first.'}</div>`;
                }
            } catch (err) {
                output.innerHTML = `<div style="color: var(--accent-red);">Error: ${err.message}</div>`;
            }
        }
        
        function groupTransitionsByActor(sm) {
            const actors = {};
            
            // Dynamically extract prefixes from state names
            // Convention: states are named like "actorname_statename"
            const extractPrefix = (state) => {
                const idx = state.indexOf('_');
                if (idx > 0) {
                    return state.substring(0, idx + 1); // include underscore
                }
                return null;
            };
            
            // Build prefix map from all states we see
            const prefixToActor = new Map();
            
            sm.transitions.forEach(t => {
                [t.from, t.to].forEach(state => {
                    const prefix = extractPrefix(state);
                    if (prefix && !prefixToActor.has(prefix)) {
                        // Actor name is prefix without underscore
                        prefixToActor.set(prefix, prefix.slice(0, -1));
                    }
                });
            });
            
            sm.initial.forEach(s => {
                const prefix = extractPrefix(s);
                if (prefix && !prefixToActor.has(prefix)) {
                    prefixToActor.set(prefix, prefix.slice(0, -1));
                }
            });
            
            // Group transitions by actor
            sm.transitions.forEach(t => {
                const prefix = extractPrefix(t.from) || extractPrefix(t.to);
                if (!prefix) return;
                
                const actor = prefixToActor.get(prefix);
                if (!actor) return;
                
                if (!actors[actor]) {
                    actors[actor] = { transitions: [], initial: [] };
                }
                actors[actor].transitions.push(t);
            });
            
            // Add initial states
            sm.initial.forEach(s => {
                const prefix = extractPrefix(s);
                if (!prefix) return;
                
                const actor = prefixToActor.get(prefix);
                if (!actor) return;
                
                if (!actors[actor]) {
                    actors[actor] = { transitions: [], initial: [] };
                }
                actors[actor].initial.push(s);
            });
            
            return actors;
        }
        
        function generateActorPanes(actorMachines) {
            // Get actors in sorted order (no hardcoded list)
            const actorOrder = Object.keys(actorMachines).sort();
            
            let html = `<div style="
                display: flex; 
                flex-direction: column;
                gap: 16px; 
                overflow: auto;
                max-height: 100%;
                padding: 4px;
            ">`;
            
            for (const actor of actorOrder) {
                const sm = actorMachines[actor];
                if (!sm) continue;
                
                let code = 'stateDiagram-v2\n';
                code += `    direction LR\n`;
                
                sm.initial.forEach(s => {
                    code += `    [*] --> ${s}\n`;
                });
                
                sm.transitions.forEach(t => {
                    let label = sanitizeMermaidLabel(toUnicodeLogic(t.label));
                    const prob = transitionProbabilities.get(transitionKey(t.from, t.label, t.to))
                        || transitionProbabilitiesByLabel.get(t.label);
                    if (prob) {
                        label = `${label} (${prob})`;
                    }
                    if (/^(send_|recv_)/.test(t.label)) {
                        const dest = actorFromState(t.to);
                        label = `${label} to ${dest}`;
                    }
                    code += `    ${t.from} --> ${t.to}: ${label}\n`;
                });
                
                html += `
                    <div style="
                        background: var(--bg-tertiary); 
                        padding: 12px; 
                        border-radius: 6px;
                        min-height: 120px;
                        overflow-x: auto;
                    ">
                        <h4 style="margin: 0 0 8px 0; color: var(--accent-blue);">${actor}</h4>
                        ${actorDescriptions.get(actor) ? `<div style="margin: 0 0 8px 0; color: var(--text-secondary); font-size: 0.85rem;">${escapeHtml(actorDescriptions.get(actor))}</div>` : ''}
                        <div style="overflow-x: auto; min-width: max-content;">
                            <pre class="mermaid" style="margin: 0;">${code}</pre>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            return html;
        }
        
        function generateStateMachineMermaid(data) {
            if (!data || !data.transitions || data.transitions.length === 0) {
                return null;
            }
            
            let code = 'stateDiagram-v2\n';
            
            if (data.initial && data.initial.length > 0) {
                data.initial.forEach(s => {
                    code += `    [*] --> ${s}\n`;
                });
            }
            
            if (data.transitions) {
                data.transitions.forEach(t => {
                    let label = sanitizeMermaidLabel(toUnicodeLogic(t.label));
                    const prob = transitionProbabilities.get(transitionKey(t.from, t.label, t.to))
                        || transitionProbabilitiesByLabel.get(t.label);
                    if (prob) {
                        label = `${label} (${prob})`;
                    }
                    if (/^(send_|recv_)/.test(t.label)) {
                        const dest = actorFromState(t.to);
                        label = `${label} to ${dest}`;
                    }
                    code += `    ${t.from} --> ${t.to}: ${label}\n`;
                });
            }
            
            if (data.accepting && data.accepting.length > 0) {
                data.accepting.forEach(s => {
                    code += `    ${s} --> [*]\n`;
                });
            }
            
            return code;
        }
        
        function generateSequenceMermaid(data) {
            if (!data || !data.messages || data.messages.length === 0) {
                return null;
            }
            
            let code = 'sequenceDiagram\n';
            
            if (data.lifelines) {
                data.lifelines.forEach(l => {
                    code += `    participant ${l}\n`;
                });
            }
            
            if (data.messages) {
                data.messages.forEach(m => {
                    const label = sanitizeMermaidLabel(toUnicodeLogic(m.label));
                    code += `    ${m.from}->>${m.to}: ${label}\n`;
                });
            }
            
            return code;
        }
        
        function generatePieMermaid(data) {
            if (!data || !data.slices || data.slices.length === 0) {
                return null;
            }
            
            let code = 'pie title Request Distribution\n';
            data.slices.forEach(s => {
                code += `    "${s.label}" : ${s.value}\n`;
            });
            return code;
        }
        
        function generateLineMermaid(data) {
            if (!data || !data.series || data.series.length === 0) {
                return null;
            }
            
            const allXValues = new Set();
            data.series.forEach(series => {
                if (series.points) {
                    series.points.forEach(p => allXValues.add(p.x));
                }
            });
            
            if (allXValues.size === 0) {
                return null;
            }
            
            const sortedX = [...allXValues].sort((a, b) => a - b);
            const xValues = sortedX.map(x => `"${x}"`).join(', ');
            
            let maxY = 0;
            data.series.forEach(series => {
                if (series.points) {
                    series.points.forEach(p => {
                        if (p.y > maxY) maxY = p.y;
                    });
                }
            });
            maxY += 5;
            
            let code = `xychart-beta
    title "Metrics Over Time"
    x-axis [${xValues}]
    y-axis "Value" 0 --> ${maxY}`;
            
            data.series.forEach(series => {
                if (series.points && series.points.length > 0) {
                    const pointMap = new Map();
                    series.points.forEach(p => pointMap.set(p.x, p.y));
                    const yValues = sortedX.map(x => pointMap.has(x) ? pointMap.get(x) : 0).join(', ');
                    code += `\n    line [${yValues}]`;
                }
            });
            
            return code;
        }
        
        // Generate legend HTML for line chart
        function generateLineLegend(data) {
            if (!data || !data.series || data.series.length === 0) {
                return '';
            }
            
            const colors = ['#58a6ff', '#3fb950', '#f85149', '#d29922', '#a371f7', '#f778ba'];
            
            let html = '<div style="display: flex; flex-wrap: wrap; gap: 16px; margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">';
            data.series.forEach((series, i) => {
                const color = colors[i % colors.length];
                html += `<div style="display: flex; align-items: center; gap: 6px;">
                    <div style="width: 20px; height: 3px; background: ${color};"></div>
                    <span style="color: var(--text-secondary); font-size: 0.85rem;">${series.name}</span>
                </div>`;
            });
            html += '</div>';
            return html;
        }
        
        // Example specifications
        const examples = {
            mutex: `% Mutual Exclusion Protocol
                state(free, [available]).
                state(locked, [busy]).
                
                initial(free).
                
                transition(free, acquire, locked).
                transition(locked, release, free).
                
                prop(free, available).
                prop(locked, busy).
                
                property(no_deadlock, 'Can always release', 'ag(ef(atom(available)))').`,
                
            channel: `% Buffered Channel (CSP style)
                state(empty, [can_send]).
                state(has_one, [can_send, can_recv]).
                state(full, [can_recv]).
                
                initial(empty).
                
                transition(empty, send, has_one).
                transition(has_one, send, full).
                transition(full, recv, has_one).
                transition(has_one, recv, empty).
                
                prop(empty, can_send).
                prop(has_one, can_send).
                prop(has_one, can_recv).
                prop(full, can_recv).
                
                property(liveness, 'Can always send again', 'ag(ef(atom(can_send)))').`,
                
            sequence: `% Request-Response Protocol
                channel(client_server, 1).
                channel(server_db, 1).
                
                send(client_server, request, client_idle, client_waiting).
                send(server_db, query, server_requesting, server_querying).
                send(server_db, result, database_querying, database_idle).
                send(client_server, response, server_responding, server_idle).
                
                recv(client_server, request, server_idle, server_requesting).
                recv(server_db, query, database_idle, database_querying).
                recv(server_db, result, server_querying, server_responding).
                recv(client_server, response, client_waiting, client_idle).
                
                actor(client).
                actor(server).
                actor(database).
                
                actor_initial(client, client_idle).
                actor_initial(server, server_idle).
                actor_initial(database, database_idle).
                
                actor_state(client, client_idle, [ready]).
                actor_state(client, client_waiting, [busy]).
                actor_state(server, server_idle, [ready]).
                actor_state(server, server_requesting, [busy]).
                actor_state(server, server_querying, [busy]).
                actor_state(server, server_responding, [busy]).
                actor_state(database, database_idle, [ready]).
                actor_state(database, database_querying, [busy]).
                
                actor_transition(client, client_idle, request, client_waiting).
                actor_transition(client, client_waiting, response, client_idle).
                actor_transition(server, server_idle, request, server_requesting).
                actor_transition(server, server_requesting, query, server_querying).
                actor_transition(server, server_querying, result, server_responding).
                actor_transition(server, server_responding, response, server_idle).
                actor_transition(database, database_idle, query, database_querying).
                actor_transition(database, database_querying, result, database_idle).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(completes, 'Requests complete', 'ag(or(not(atom(busy)), af(atom(ready))))').`
                ,
            bread_company: `% Bread Company Operations
                doc(title, 'Bread Company Operations').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'A bread company with production, logistics, retail, and customer demand.').
                doc(description, 'Actors communicate via messages. Production and customer arrivals are probabilistic chance nodes. Pie/line charts should visualize message volume by sender.').
                
                doc(role_factory, 'Factory mixes, kneads, bakes, cools, and bags bread.').
                doc(role_bakers, 'Bakers operate machines, knead dough, and manage oven loads.').
                doc(role_truck, 'Truck loads bagged bread and delivers to the storefront.').
                doc(role_storefront, 'Storefront receives bread, stocks racks, sells to customers, and manages aging inventory.').
                doc(role_customers, 'Customers arrive stochastically and buy bread from the fresh rack.').
                doc(role_charity, 'Charity rack receives bread older than 3 days.').
                doc(role_accounting, 'Accounting tracks wages, revenue, and profitability.').
                
                doc(viz_statemachine, 'State machines show operational modes per actor. Chance states model probabilistic events.').
                doc(viz_sequence, 'Sequence diagram shows a typical day: production -> delivery -> stocking -> customer sales -> accounting updates.').
                doc(viz_pie, 'Pie chart shows message volume by sender (actor).').
                doc(viz_line, 'Line chart shows cumulative messages by sender over sequence order.').
                
                actor(factory).
                actor(bakers).
                actor(truck).
                actor(storefront).
                actor(customers).
                actor(charity).
                actor(accounting).
                
                actor_initial(factory, factory_idle).
                actor_initial(bakers, bakers_idle).
                actor_initial(truck, truck_idle).
                actor_initial(storefront, store_closed).
                actor_initial(customers, customers_idle).
                actor_initial(charity, charity_idle).
                actor_initial(accounting, accounting_break_even).
                
                actor_state(factory, factory_idle, [ready]).
                actor_state(factory, factory_chance_batch, [chance]).
                actor_state(factory, factory_mixing, [in_progress]).
                actor_state(factory, factory_kneading, [in_progress]).
                actor_state(factory, factory_baking, [in_progress]).
                actor_state(factory, factory_cooling, [in_progress]).
                actor_state(factory, factory_bagging, [bagged_stock]).
                actor_state(factory, factory_waiting_truck, [bagged_stock]).
                
                actor_state(bakers, bakers_idle, [available]).
                actor_state(bakers, bakers_running_mixer, [busy]).
                actor_state(bakers, bakers_kneading, [busy]).
                actor_state(bakers, bakers_loading_oven, [busy]).
                actor_state(bakers, bakers_unloading_oven, [busy]).
                
                actor_state(truck, truck_idle, [available]).
                actor_state(truck, truck_loading, [busy]).
                actor_state(truck, truck_in_transit, [busy]).
                actor_state(truck, truck_unloading, [busy]).
                
                actor_state(storefront, store_closed, [closed]).
                actor_state(storefront, store_open, [open]).
                actor_state(storefront, store_stocking, [open]).
                actor_state(storefront, store_fresh_rack_full, [fresh_stock]).
                actor_state(storefront, store_fresh_rack_low, [fresh_stock, low_stock]).
                actor_state(storefront, store_charity_rack, [has_charity_stock]).
                actor_state(storefront, store_rotating_stock, [aging_stock]).
                actor_state(storefront, store_sold_out, [no_stock]).
                
                actor_state(customers, customers_idle, [chance]).
                actor_state(customers, customers_arriving_low, [arriving]).
                actor_state(customers, customers_arriving_high, [arriving]).
                actor_state(customers, customers_buying, [buying]).
                
                actor_state(charity, charity_idle, [ready]).
                actor_state(charity, charity_receiving, [receiving]).
                actor_state(charity, charity_stocked, [has_stock]).
                
                actor_state(accounting, accounting_break_even, [neutral]).
                actor_state(accounting, accounting_profitable, [profitable]).
                actor_state(accounting, accounting_loss, [loss]).
                actor_state(accounting, accounting_payroll, [wages_due]).
                actor_state(accounting, accounting_revenue, [revenue_in]).
                
                actor_transition(factory, factory_idle, start_day, factory_chance_batch).
                actor_transition(factory, factory_chance_batch, batch_low, factory_mixing).
                actor_transition(factory, factory_chance_batch, batch_high, factory_mixing).
                actor_transition(factory, factory_mixing, mixed, factory_kneading).
                actor_transition(factory, factory_kneading, kneaded, factory_baking).
                actor_transition(factory, factory_baking, baked, factory_cooling).
                actor_transition(factory, factory_cooling, cooled, factory_bagging).
                actor_transition(factory, factory_bagging, bagged, factory_waiting_truck).
                actor_transition(factory, factory_waiting_truck, loaded, factory_idle).
                
                actor_transition(bakers, bakers_idle, run_mixer, bakers_running_mixer).
                actor_transition(bakers, bakers_running_mixer, dough_ready, bakers_kneading).
                actor_transition(bakers, bakers_kneading, dough_kneaded, bakers_loading_oven).
                actor_transition(bakers, bakers_loading_oven, oven_loaded, bakers_unloading_oven).
                actor_transition(bakers, bakers_unloading_oven, oven_unloaded, bakers_idle).
                
                actor_transition(truck, truck_idle, arrive_factory, truck_loading).
                actor_transition(truck, truck_loading, loaded_truck, truck_in_transit).
                actor_transition(truck, truck_in_transit, arrive_store, truck_unloading).
                actor_transition(truck, truck_unloading, unloaded_store, truck_idle).
                
                actor_transition(storefront, store_closed, open_store, store_open).
                actor_transition(storefront, store_open, receive_delivery, store_stocking).
                actor_transition(storefront, store_stocking, racks_full, store_fresh_rack_full).
                actor_transition(storefront, store_fresh_rack_full, sell_bread, store_fresh_rack_low).
                actor_transition(storefront, store_fresh_rack_low, sell_out, store_sold_out).
                actor_transition(storefront, store_fresh_rack_low, restock, store_fresh_rack_full).
                actor_transition(storefront, store_fresh_rack_full, rotate_stock, store_rotating_stock).
                actor_transition(storefront, store_rotating_stock, moved_to_charity, store_charity_rack).
                actor_transition(storefront, store_charity_rack, charity_rack_set, store_open).
                actor_transition(storefront, store_sold_out, close_store, store_closed).
                
                actor_transition(customers, customers_idle, chance_arrival, customers_arriving_low).
                actor_transition(customers, customers_idle, chance_arrival_peak, customers_arriving_high).
                actor_transition(customers, customers_arriving_low, browse, customers_buying).
                actor_transition(customers, customers_arriving_high, rush, customers_buying).
                actor_transition(customers, customers_buying, checkout, customers_idle).
                
                actor_transition(charity, charity_idle, notify_pickup, charity_receiving).
                actor_transition(charity, charity_receiving, stocked, charity_stocked).
                actor_transition(charity, charity_stocked, clear_rack, charity_idle).
                
                actor_transition(accounting, accounting_break_even, record_wages, accounting_payroll).
                actor_transition(accounting, accounting_payroll, wages_paid, accounting_loss).
                actor_transition(accounting, accounting_loss, record_sales, accounting_revenue).
                actor_transition(accounting, accounting_revenue, profit_high, accounting_profitable).
                actor_transition(accounting, accounting_revenue, profit_low, accounting_break_even).
                actor_transition(accounting, accounting_profitable, record_wages, accounting_payroll).
                
                msg_annotation(start_day, send, bakers).
                msg_annotation(mixed, send, bakers).
                msg_annotation(kneaded, send, bakers).
                msg_annotation(baked, send, bakers).
                msg_annotation(cooled, send, bakers).
                msg_annotation(bagged, send, truck).
                msg_annotation(loaded_truck, send, truck).
                msg_annotation(arrive_store, send, storefront).
                msg_annotation(receive_delivery, recv, truck).
                msg_annotation(sell_bread, recv, customers).
                msg_annotation(checkout, send, accounting).
                msg_annotation(moved_to_charity, send, charity).
                
                channel(factory_bakers, 1).
                channel(factory_truck, 1).
                channel(truck_store, 1).
                channel(store_customers, 1).
                channel(store_accounting, 1).
                channel(store_charity, 1).
                
                send(factory_bakers, start_day, factory_idle, factory_chance_batch).
                send(factory_bakers, mixed, bakers_running_mixer, bakers_kneading).
                send(factory_bakers, kneaded, bakers_kneading, bakers_loading_oven).
                send(factory_bakers, baked, bakers_loading_oven, bakers_unloading_oven).
                send(factory_bakers, cooled, bakers_unloading_oven, bakers_idle).
                
                send(factory_truck, bagged, factory_bagging, factory_waiting_truck).
                send(factory_truck, loaded_truck, truck_loading, truck_in_transit).
                
                send(truck_store, deliver_bread, truck_in_transit, truck_unloading).
                send(truck_store, receive_delivery, store_stocking, store_fresh_rack_full).
                
                send(store_customers, arrive, customers_idle, customers_arriving_low).
                send(store_customers, offer_bread, store_fresh_rack_full, store_fresh_rack_low).
                send(store_customers, purchase_8, customers_buying, customers_idle).
                
                send(store_accounting, record_sale, store_fresh_rack_low, store_fresh_rack_low).
                
                send(store_charity, move_old_stock, store_rotating_stock, store_charity_rack).
                
                recv(factory_bakers, start_day, bakers_idle, bakers_running_mixer).
                recv(factory_bakers, mixed, factory_mixing, factory_kneading).
                recv(factory_bakers, kneaded, factory_kneading, factory_baking).
                recv(factory_bakers, baked, factory_baking, factory_cooling).
                recv(factory_bakers, cooled, factory_cooling, factory_bagging).
                
                recv(factory_truck, bagged, truck_idle, truck_loading).
                recv(factory_truck, loaded_truck, factory_waiting_truck, factory_idle).
                
                recv(truck_store, deliver_bread, store_open, store_stocking).
                recv(truck_store, receive_delivery, truck_unloading, truck_idle).
                
                recv(store_customers, arrive, store_open, store_open).
                recv(store_customers, offer_bread, customers_arriving_low, customers_buying).
                recv(store_customers, purchase_8, store_fresh_rack_low, store_fresh_rack_low).
                
                recv(store_accounting, record_sale, accounting_loss, accounting_revenue).
                
                recv(store_charity, move_old_stock, charity_idle, charity_receiving).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(profitable_eventually, 'Business can reach profitability', 'ag(ef(atom(profitable)))').
                property(avoid_permanent_stockout, 'Fresh rack not permanently empty', 'ag(ef(atom(fresh_stock)))').
                property(charity_receives_old_stock, 'Old stock eventually moved to charity', 'ag(ef(atom(has_charity_stock)))').
                property(wages_recorded, 'Payroll is eventually recorded', 'ag(ef(atom(wages_due)))').
                property(open_store_reachable, 'Store can open from initial conditions', 'ag(ef(atom(open)))').`
                ,
            yahalom: `% Yahalom Key Exchange Protocol
                doc(title, 'Yahalom Protocol').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'Three-party key exchange protocol with a trusted server.').
                doc(description, 'Actors A and B use server S to establish a shared session key Kab.').
                
                doc(role_initiator, 'A initiates the run by sending a fresh nonce to B.').
                doc(role_responder, 'B responds and relays A and fresh nonces to S.').
                doc(role_server, 'S creates a session key and returns tickets for A and B.').
                doc(vars, 'Na,Nb are nonces; Kab is a session key; ticket_b is a ticket encrypted for B (e.g., {Kab,A}_Kbs).').
                doc(role_attacker, 'Attacker can steal tickets or forge them after compromising S.').
                
                doc(viz_sequence, 'Sequence is derived from send/recv on channels.').
                doc(viz_statemachine, 'Explicit actor states make the protocol easy to diagram.').
                
                actor(a).
                actor(b).
                actor(s).
                actor(attacker).
                
                actor_initial(a, a_idle).
                actor_initial(b, b_idle).
                actor_initial(s, s_idle).
                actor_initial(attacker, attacker_idle).
                
                actor_state(a, a_idle, [ready]).
                actor_state(a, a_sent_na, [waiting]).
                actor_state(a, a_got_ticket, [has_ticket]).
                actor_state(a, a_established, [kab_established]).
                
                actor_state(b, b_idle, [ready]).
                actor_state(b, b_got_na, [waiting]).
                actor_state(b, b_sent_to_s, [waiting]).
                actor_state(b, b_established, [kab_established]).
                
                actor_state(s, s_idle, [ready]).
                actor_state(s, s_received, [processing]).
                actor_state(s, s_responded, [responded]).
                
                actor_state(attacker, attacker_idle, [ready]).
                actor_state(attacker, attacker_got_ticket, [attacker_has_ticket]).
                actor_state(attacker, attacker_got_kab, [attacker_has_kab]).
                actor_state(attacker, attacker_compromised, [attacker_can_forge]).
                
                actor_transition(a, a_idle, send_ab_na, a_sent_na).
                actor_transition(a, a_sent_na, recv_s_to_a, a_got_ticket).
                actor_transition(a, a_got_ticket, send_ticket_to_b, a_established).
                
                actor_transition(b, b_idle, recv_ab_na, b_got_na).
                actor_transition(b, b_got_na, send_to_s, b_sent_to_s).
                actor_transition(b, b_sent_to_s, recv_a_ticket, b_established).
                
                actor_transition(s, s_idle, recv_b_to_s, s_received).
                actor_transition(s, s_received, send_s_to_a, s_responded).
                actor_transition(s, s_responded, reset, s_idle).
                
                actor_transition(attacker, attacker_idle, steal_ticket, attacker_got_ticket).
                actor_transition(attacker, attacker_got_ticket, use_ticket, attacker_got_kab).
                actor_transition(attacker, attacker_idle, compromise_s, attacker_compromised).
                actor_transition(attacker, attacker_compromised, forge_ticket, attacker_got_ticket).
                
                transition_guard(attacker_idle, steal_ticket, attacker_got_ticket, chance_steal).
                transition_guard(attacker_idle, compromise_s, attacker_compromised, chance_compromise).
                
                chance_steal :- dice0(0.0, 0.7).
                chance_compromise :- dice0(0.7, 1.0).
                
                transition_guard(attacker_idle, steal_ticket, attacker_got_ticket, chance_steal).
                transition_guard(attacker_idle, compromise_s, attacker_compromised, chance_compromise).
                
                chance_steal :- dice0(0.0, 0.7).
                chance_compromise :- dice0(0.7, 1.0).
                
                channel(a_b, 1).
                channel(b_s, 1).
                channel(s_a, 1).
                channel(a_b_ticket, 1).
                
                message_format(na, 'A,Na').
                message_format(a_na_nb, 'A,Na,Nb').
                message_format(kab_ticket, 'Kab,ticket_b,Nb').
                
                send(a_b, na, a_idle, a_sent_na).
                send(b_s, a_na_nb, b_got_na, b_sent_to_s).
                send(s_a, kab_ticket, s_received, s_responded).
                send(a_b_ticket, kab_ticket, a_got_ticket, a_established).
                
                recv(a_b, na, b_idle, b_got_na).
                recv(b_s, a_na_nb, s_idle, s_received).
                recv(s_a, kab_ticket, a_sent_na, a_got_ticket).
                recv(a_b_ticket, kab_ticket, b_sent_to_s, b_established).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(a_establishes_key, 'A can establish Kab', 'ag(ef(atom(kab_established)))').
                property(b_establishes_key, 'B can establish Kab', 'ag(ef(atom(kab_established)))').
                property(attacker_can_get_ticket, 'Attacker can obtain a ticket', 'ef(atom(attacker_has_ticket))').
                property(attacker_can_get_kab, 'Attacker can obtain Kab', 'ef(atom(attacker_has_kab))').
                property(attacker_never_gets_kab, 'Attacker never learns Kab', 'ag(not(atom(attacker_has_kab)))').`
                ,
            needham_schroeder: `% Needham-Schroeder (Symmetric Key) Protocol
                doc(title, 'Needham-Schroeder (Symmetric Key)').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'A and B use a trusted server S to establish a session key Kab.').
                doc(description, 'Sequence derived from send/recv on channels.').
                
                doc(role_initiator, 'A initiates by requesting a session key for B.').
                doc(role_responder, 'B completes challenge-response with A.').
                doc(role_server, 'S issues Kab and a ticket for B.').
                doc(vars, 'Na,Nb are nonces; Kab is a session key; ticket_b is a ticket encrypted for B (e.g., {Kab,A}_Kbs).').
                doc(role_attacker, 'Attacker can steal tickets or forge them after compromising S.').
                
                actor(a).
                actor(b).
                actor(s).
                actor(attacker).
                
                actor_initial(a, a_idle).
                actor_initial(b, b_idle).
                actor_initial(s, s_idle).
                actor_initial(attacker, attacker_idle).
                
                actor_state(a, a_idle, [ready]).
                actor_state(a, a_sent_req, [waiting]).
                actor_state(a, a_got_ticket, [has_ticket]).
                actor_state(a, a_sent_ticket, [waiting]).
                actor_state(a, a_established, [kab_established]).
                
                actor_state(b, b_idle, [ready]).
                actor_state(b, b_got_ticket, [has_ticket]).
                actor_state(b, b_sent_nb, [waiting]).
                actor_state(b, b_established, [kab_established]).
                
                actor_state(s, s_idle, [ready]).
                actor_state(s, s_received, [processing]).
                actor_state(s, s_responded, [responded]).
                
                actor_state(attacker, attacker_idle, [ready]).
                actor_state(attacker, attacker_got_ticket, [attacker_has_ticket]).
                actor_state(attacker, attacker_got_kab, [attacker_has_kab]).
                actor_state(attacker, attacker_compromised, [attacker_can_forge]).
                
                actor_transition(a, a_idle, send_req, a_sent_req).
                actor_transition(a, a_sent_req, recv_ticket, a_got_ticket).
                actor_transition(a, a_got_ticket, send_ticket, a_sent_ticket).
                actor_transition(a, a_sent_ticket, recv_nb, a_established).
                
                actor_transition(b, b_idle, recv_ticket, b_got_ticket).
                actor_transition(b, b_got_ticket, send_nb, b_sent_nb).
                actor_transition(b, b_sent_nb, recv_nb_ack, b_established).
                
                actor_transition(s, s_idle, recv_req, s_received).
                actor_transition(s, s_received, send_ticket, s_responded).
                actor_transition(s, s_responded, reset, s_idle).
                
                actor_transition(attacker, attacker_idle, steal_ticket, attacker_got_ticket).
                actor_transition(attacker, attacker_got_ticket, use_ticket, attacker_got_kab).
                actor_transition(attacker, attacker_idle, compromise_s, attacker_compromised).
                actor_transition(attacker, attacker_compromised, forge_ticket, attacker_got_ticket).
                
                channel(a_s, 1).
                channel(s_a, 1).
                channel(a_b, 1).
                channel(b_a, 1).
                
                message_format(req_ab_na, 'A,B,Na').
                message_format(ticket_kab, 'Kab,ticket_b').
                message_format(nb, 'Nb').
                message_format(nb_ack, 'Nb-1').
                
                send(a_s, req_ab_na, a_idle, a_sent_req).
                send(s_a, ticket_kab, s_received, s_responded).
                send(a_b, ticket_kab, a_got_ticket, a_sent_ticket).
                send(b_a, nb, b_got_ticket, b_sent_nb).
                send(a_b, nb_ack, a_sent_ticket, a_established).
                
                recv(a_s, req_ab_na, s_idle, s_received).
                recv(s_a, ticket_kab, a_sent_req, a_got_ticket).
                recv(a_b, ticket_kab, b_idle, b_got_ticket).
                recv(b_a, nb, a_sent_ticket, a_established).
                recv(a_b, nb_ack, b_sent_nb, b_established).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(a_establishes_key, 'A can establish Kab', 'ag(ef(atom(kab_established)))').
                property(b_establishes_key, 'B can establish Kab', 'ag(ef(atom(kab_established)))').
                property(attacker_can_get_ticket, 'Attacker can obtain a ticket', 'ef(atom(attacker_has_ticket))').
                property(attacker_can_get_kab, 'Attacker can obtain Kab', 'ef(atom(attacker_has_kab))').
                property(attacker_never_gets_kab, 'Attacker never learns Kab', 'ag(not(atom(attacker_has_kab)))').`
                ,
            kerberos: `% Kerberos (Simplified)
                doc(title, 'Kerberos (Simplified)').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'Client obtains tickets from AS and TGS to access a service.').
                doc(description, 'Sequence derived from send/recv on channels.').
                
                doc(role_client, 'Client requests tickets and authenticates to the service.').
                doc(role_as, 'Authentication Server issues a TGT.').
                doc(role_tgs, 'Ticket Granting Server issues service tickets.').
                doc(role_service, 'Service accepts the client ticket.').
                doc(vars, 'TGT is the ticket-granting ticket; Kc_tgs is client-TGS session key; Kc_svc is client-service session key; Auth is an authenticator; SvcTicket is the service ticket.').
                doc(role_attacker, 'Attacker can steal tickets or forge them after compromising TGS.').
                
                actor(client).
                actor(as).
                actor(tgs).
                actor(service).
                actor(attacker).
                
                actor_initial(client, c_idle).
                actor_initial(as, as_idle).
                actor_initial(tgs, tgs_idle).
                actor_initial(service, s_idle).
                actor_initial(attacker, attacker_idle).
                
                actor_state(client, c_idle, [ready]).
                actor_state(client, c_sent_as_req, [waiting]).
                actor_state(client, c_got_tgt, [has_tgt]).
                actor_state(client, c_sent_tgs_req, [waiting]).
                actor_state(client, c_got_svc_ticket, [has_ticket]).
                actor_state(client, c_authenticated, [authed]).
                
                actor_state(as, as_idle, [ready]).
                actor_state(as, as_received, [processing]).
                actor_state(as, as_responded, [responded]).
                
                actor_state(tgs, tgs_idle, [ready]).
                actor_state(tgs, tgs_received, [processing]).
                actor_state(tgs, tgs_responded, [responded]).
                
                actor_state(service, s_idle, [ready]).
                actor_state(service, s_received, [processing]).
                actor_state(service, s_accepted, [authed]).
                
                actor_state(attacker, attacker_idle, [ready]).
                actor_state(attacker, attacker_got_tgt, [attacker_has_tgt]).
                actor_state(attacker, attacker_got_ticket, [attacker_has_ticket]).
                actor_state(attacker, attacker_authed, [attacker_authed]).
                actor_state(attacker, attacker_compromised, [attacker_can_forge]).
                
                actor_transition(client, c_idle, send_as_req, c_sent_as_req).
                actor_transition(client, c_sent_as_req, recv_as_rep, c_got_tgt).
                actor_transition(client, c_got_tgt, send_tgs_req, c_sent_tgs_req).
                actor_transition(client, c_sent_tgs_req, recv_tgs_rep, c_got_svc_ticket).
                actor_transition(client, c_got_svc_ticket, send_ap_req, c_authenticated).
                
                actor_transition(as, as_idle, recv_as_req, as_received).
                actor_transition(as, as_received, send_as_rep, as_responded).
                actor_transition(as, as_responded, reset, as_idle).
                
                actor_transition(tgs, tgs_idle, recv_tgs_req, tgs_received).
                actor_transition(tgs, tgs_received, send_tgs_rep, tgs_responded).
                actor_transition(tgs, tgs_responded, reset, tgs_idle).
                
                actor_transition(service, s_idle, recv_ap_req, s_received).
                actor_transition(service, s_received, send_ap_rep, s_accepted).
                actor_transition(service, s_accepted, reset, s_idle).
                
                actor_transition(attacker, attacker_idle, steal_tgt, attacker_got_tgt).
                actor_transition(attacker, attacker_got_tgt, use_tgt, attacker_got_ticket).
                actor_transition(attacker, attacker_idle, steal_ticket, attacker_got_ticket).
                actor_transition(attacker, attacker_got_ticket, use_ticket, attacker_authed).
                actor_transition(attacker, attacker_idle, compromise_tgs, attacker_compromised).
                actor_transition(attacker, attacker_compromised, forge_ticket, attacker_got_ticket).
                
                transition_guard(attacker_idle, steal_tgt, attacker_got_tgt, chance_steal_tgt).
                transition_guard(attacker_idle, steal_ticket, attacker_got_ticket, chance_steal_ticket).
                transition_guard(attacker_idle, compromise_tgs, attacker_compromised, chance_compromise).
                
                chance_steal_tgt :- dice0(0.0, 0.5).
                chance_steal_ticket :- dice0(0.5, 0.8).
                chance_compromise :- dice0(0.8, 1.0).
                
                channel(c_as, 1).
                channel(as_c, 1).
                channel(c_tgs, 1).
                channel(tgs_c, 1).
                channel(c_svc, 1).
                channel(svc_c, 1).
                
                message_format(as_req, 'C').
                message_format(as_rep, 'TGT,Kc_tgs').
                message_format(tgs_req, 'TGT,Auth').
                message_format(tgs_rep, 'SvcTicket,Kc_svc').
                message_format(ap_req, 'SvcTicket,Auth').
                message_format(ap_rep, 'Ack').
                
                send(c_as, as_req, c_idle, c_sent_as_req).
                send(as_c, as_rep, as_received, as_responded).
                send(c_tgs, tgs_req, c_got_tgt, c_sent_tgs_req).
                send(tgs_c, tgs_rep, tgs_received, tgs_responded).
                send(c_svc, ap_req, c_got_svc_ticket, c_authenticated).
                send(svc_c, ap_rep, s_received, s_accepted).
                
                recv(c_as, as_req, as_idle, as_received).
                recv(as_c, as_rep, c_sent_as_req, c_got_tgt).
                recv(c_tgs, tgs_req, tgs_idle, tgs_received).
                recv(tgs_c, tgs_rep, c_sent_tgs_req, c_got_svc_ticket).
                recv(c_svc, ap_req, s_idle, s_received).
                recv(svc_c, ap_rep, c_authenticated, c_authenticated).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(client_authenticates, 'Client can authenticate to service', 'ag(ef(atom(authed)))').
                property(attacker_can_get_ticket, 'Attacker can obtain a service ticket', 'ef(atom(attacker_has_ticket))').
                property(attacker_can_authenticate, 'Attacker can authenticate to service', 'ef(atom(attacker_authed))').
                property(attacker_never_authenticates, 'Attacker never authenticates', 'ag(not(atom(attacker_authed)))').`
        };
        
        function loadExample(name) {
            document.getElementById('specEditor').value = examples[name];
            switchTab('spec');
        }

        async function loadExampleAndApply(name) {
            loadExample(name);
            await applySpec();
            switchTab('states');
        }

        function toUnicodeLogic(text) {
            if (!text) {
                return '';
            }
            return text
                .replace(/->/g, '‚Üí')
                .replace(/\/\\/g, '‚àß')
                .replace(/\\\//g, '‚à®');
        }

        function sanitizeMermaidLabel(text) {
            if (!text) {
                return '';
            }
            return text.replace(/%/g, ' percent');
        }

        function actorFromState(state) {
            if (!state) {
                return 'unknown';
            }
            const idx = state.indexOf('_');
            return idx > 0 ? state.slice(0, idx) : state;
        }

        function transitionKey(from, label, to) {
            return `${from}|${label}|${to}`;
        }

        function formatProbability(low, high) {
            const lowNum = parseFloat(low);
            const highNum = parseFloat(high);
            if (Number.isFinite(lowNum) && Number.isFinite(highNum)) {
                const p = Math.max(0, highNum - lowNum);
                const pStr = p.toFixed(2).replace(/\.00$/, '');
                return `p=${pStr}`;
            }
            return `[${low},${high}]`;
        }

        function updateTransitionProbabilities(source) {
            transitionProbabilities.clear();
            transitionProbabilitiesByLabel.clear();
            if (!source) {
                return;
            }
            const guardRanges = new Map();
            const guardRegex = /(^|\n)\s*([a-z][A-Za-z0-9_]*)\s*:-\s*dice0\(\s*([^,]+)\s*,\s*([^)]+)\)\s*\.\s*/g;
            let match;
            while ((match = guardRegex.exec(source)) !== null) {
                const guard = match[2];
                const low = match[3].trim();
                const high = match[4].trim();
                guardRanges.set(guard, { low, high });
            }

            const guardUseRegex = /transition_guard\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\)\s*\./g;
            while ((match = guardUseRegex.exec(source)) !== null) {
                const from = match[1].trim();
                const label = match[2].trim();
                const to = match[3].trim();
                const guard = match[4].trim();
                const range = guardRanges.get(guard);
                if (range) {
                    const prob = formatProbability(range.low, range.high);
                    transitionProbabilities.set(transitionKey(from, label, to), prob);
                    if (!transitionProbabilitiesByLabel.has(label)) {
                        transitionProbabilitiesByLabel.set(label, prob);
                    }
                }
            }
        }

        function ctlToMath(text) {
            if (!text) {
                return '';
            }

            const tokens = [];
            const re = /[A-Za-z_][A-Za-z0-9_]*|->|[(),]/g;
            let match;
            while ((match = re.exec(text)) !== null) {
                tokens.push(match[0]);
            }

            let idx = 0;
            const peek = () => tokens[idx];
            const next = () => tokens[idx++];
            const hasNext = () => idx < tokens.length;

            const wrap = (s) => {
                if (!s) return s;
                if (/[ \t‚àß‚à®‚Üí]/.test(s) || s.includes(' U ') || s.startsWith('¬¨')) {
                    return `(${s})`;
                }
                return s;
            };

            const parseExpr = () => {
                const tok = peek();
                if (!tok) {
                    return '';
                }
                if (/^[A-Za-z_]/.test(tok)) {
                    const ident = next();
                    if (peek() === '(') {
                        next(); // (
                        const args = [];
                        if (peek() !== ')') {
                            while (hasNext()) {
                                args.push(parseExpr());
                                if (peek() === ',') {
                                    next();
                                    continue;
                                }
                                break;
                            }
                        }
                        if (peek() === ')') {
                            next();
                        }
                        return renderFunc(ident, args);
                    }
                    return ident;
                }
                return next();
            };

            const renderFunc = (ident, args) => {
                switch (ident) {
                case 'atom':
                    return args[0] || '';
                case 'not':
                    return `¬¨${wrap(args[0] || '')}`;
                case 'and':
                    return `(${wrap(args[0])} ‚àß ${wrap(args[1])})`;
                case 'or':
                    return `(${wrap(args[0])} ‚à® ${wrap(args[1])})`;
                case 'ex':
                    return `‚àÉX(${args[0] || ''})`;
                case 'ax':
                    return `‚àÄX(${args[0] || ''})`;
                case 'ef':
                    return `‚àÉF(${args[0] || ''})`;
                case 'af':
                    return `‚àÄF(${args[0] || ''})`;
                case 'eg':
                    return `‚àÉG(${args[0] || ''})`;
                case 'ag':
                    return `‚àÄG(${args[0] || ''})`;
                case 'eu':
                    return `‚àÉ(${args[0] || ''} U ${args[1] || ''})`;
                case 'au':
                    return `‚àÄ(${args[0] || ''} U ${args[1] || ''})`;
                default:
                    return `${ident}(${args.join(', ')})`;
                }
            };

            try {
                const parsed = parseExpr();
                if (!parsed) {
                    return toUnicodeLogic(text);
                }
                return toUnicodeLogic(parsed);
            } catch (_err) {
                return toUnicodeLogic(text);
            }
        }
        
        const MAX_AUTO_FIX_RETRIES = 3;
        
        async function loadProperties() {
            try {
                const resp = await fetch('/api/properties');
                const data = await resp.json();
                
                const listDiv = document.getElementById('propertyList');
                if (data.success && data.properties && data.properties.length > 0) {
                    const input = document.getElementById('propertyInput');
                    if (input && data.properties[0].formula) {
                        input.placeholder = data.properties[0].formula;
                    }
                    listDiv.innerHTML = data.properties.map(p => {
                        let statusIcon = '';
                        let statusColor = '';
                        if (p.error) {
                            statusIcon = '‚ö†Ô∏è';
                            statusColor = 'var(--accent-yellow)';
                        } else if (p.satisfied === true) {
                            statusIcon = '‚úì';
                            statusColor = 'var(--accent-green)';
                        } else if (p.satisfied === false) {
                            statusIcon = '‚úó';
                            statusColor = 'var(--accent-red)';
                        }
                        
                        const formula = p.formula || '';
                        const ctlMath = ctlToMath(formula);
                        const mathLine = (ctlMath && ctlMath !== formula)
                            ? `<div style="font-size: 0.8rem; color: var(--text-primary); margin-left: 28px; font-family: monospace;">${escapeHtml(ctlMath)}</div>`
                            : '';

                        return `
                        <div style="margin-bottom: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="color: ${statusColor}; font-size: 1.2rem;">${statusIcon}</span>
                                <strong style="color: var(--accent-blue);">${p.name}</strong>
                            </div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-left: 28px;">${p.description}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-purple); margin-left: 28px; font-family: monospace;">${escapeHtml(formula)}</div>
                            ${mathLine}
                            ${p.error ? `<div style="font-size: 0.8rem; color: var(--accent-red); margin-left: 28px;">Error: ${p.error}</div>` : ''}
                        </div>
                    `}).join('');
                } else {
                    listDiv.innerHTML = '<div style="color: var(--text-secondary);">No properties defined in spec.</div><div style="margin-top: 8px;"><button class="btn btn-secondary" onclick="loadExampleAndApply(\'yahalom\')">Load Yahalom</button></div>';
                }
            } catch (err) {
                console.error('Error loading properties:', err);
            }
        }
        
        async function checkNamedProperty(name, formula) {
            document.getElementById('propertyInput').value = formula;
            await checkProperty();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDescription(text) {
            const lines = text.split('\n').map(line => line.trim()).filter(Boolean);
            const isBulleted = lines.length > 0 && lines.every(line => line.startsWith('- '));
            if (isBulleted) {
                const items = lines.map(line => `<li>${escapeHtml(line.slice(2))}</li>`).join('');
                return `<ul style="margin: 0 0 0 18px; padding: 0;">${items}</ul>`;
            }
            return escapeHtml(text).replace(/\n/g, '<br>');
        }

        async function updateTerminalHelp() {
            const help = document.getElementById('terminalHelp');
            if (!help) {
                return;
            }
            try {
                const [actorsResp, propertiesResp, docsResp] = await Promise.all([
                    fetch('/api/actors'),
                    fetch('/api/properties'),
                    fetch('/api/docs')
                ]);
                const actorsData = await actorsResp.json();
                const propertiesData = await propertiesResp.json();
                const docsData = await docsResp.json();

                const examples = [];
                if (actorsData.success && Array.isArray(actorsData.actors) && actorsData.actors.length > 0) {
                    examples.push('actor(X).');
                }
                if (propertiesData.success && Array.isArray(propertiesData.properties) && propertiesData.properties.length > 0) {
                    examples.push('property(Name, Desc, Formula).');
                }
                if (docsData.success && Array.isArray(docsData.docs) && docsData.docs.length > 0) {
                    examples.push('doc(Topic, Content).');
                }

                if (examples.length === 0) {
                    help.innerHTML = `No spec loaded. <button class="btn btn-secondary" onclick="loadExampleAndApply('yahalom')">Load Yahalom</button>`;
                    return;
                }

                help.innerHTML = `Examples: <code>ls.</code> ${examples.map(ex => `<code>${escapeHtml(ex)}</code>`).join(' ')}`;
            } catch (_err) {
                help.textContent = '';
            }
        }

        async function updateCheckAvailability() {
            const input = document.getElementById('propertyInput');
            const button = document.getElementById('checkButton');
            const hint = document.getElementById('checkHint');
            if (!input || !button || !hint) {
                return;
            }
            try {
                const resp = await fetch('/api/spec');
                const data = await resp.json();
                const source = (data && data.source) ? data.source.trim() : '';
                const enabled = source.length > 0;
                input.disabled = !enabled;
                button.disabled = !enabled;
                hint.textContent = enabled
                    ? ''
                    : 'Load a spec to enable CTL checks.';
            } catch (_err) {
                input.disabled = true;
                button.disabled = true;
                hint.textContent = 'Load a spec to enable CTL checks.';
            }
        }

        async function loadSpecIntoEditor() {
            const editor = document.getElementById('specEditor');
            if (!editor) {
                return;
            }
            try {
                const resp = await fetch('/api/spec');
                const data = await resp.json();
                const source = (data && data.source) ? data.source : '';
                if (source) {
                    editor.value = source;
                }
                updateTransitionProbabilities(source);
                updateSpecBanner([], data);
            } catch (_err) {
                // Ignore; editor stays as-is.
            }
        }
        
        function formatResponse(text) {
            // Simple markdown-like formatting
            return escapeHtml(text)
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }
        
        // Initialize on page load
        loadProperties();
        loadDocs();
        updateTerminalHelp();
        updateCheckAvailability();
        
        window.addEventListener('load', () => {
            appendPromptLine(document.getElementById('queryOutput'));
            loadSpecIntoEditor().then(() => {
                updateTerminalHelp();
                updateCheckAvailability();
                if (document.getElementById('tab-states').classList.contains('active')) {
                    renderStates();
                }
                if (document.getElementById('tab-simulation').classList.contains('active')) {
                    renderSimulation();
                }
            });
        });
        
        // Keyboard shortcuts
        document.getElementById('queryOutput').addEventListener('click', () => {
            focusTerminalInput(document.getElementById('queryOutput'));
        });
        
        document.getElementById('propertyInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkProperty();
            }
        });
        
        document.getElementById('chatInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                sendChat();
            }
        });
        
        function setStatus(message, type = 'info') {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (type === 'error') {
                indicator.classList.add('error');
            } else if (type === 'success') {
                indicator.classList.add('success');
            }
        }
        
        function switchProvider() {
            const provider = document.getElementById('providerSelect').value;
            fetch('/api/provider', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ provider })
            }).then(() => {
                setStatus(`Switched to ${provider}`, 'success');
            }).catch(err => {
                setStatus(`Failed to switch: ${err.message}`, 'error');
            });
        }
        
        function generateActorStateMachinesMermaid(actors) {
            if (!actors || actors.length === 0) {
                return null;
            }
            
            let code = '';
            actors.forEach((actor, idx) => {
                if (idx > 0) code += '\n\n';
                code += `stateDiagram-v2\n`;
                code += `    direction LR\n`;
                code += `    %% ${actor.actor}\n`;
                
                if (actor.initial) {
                    code += `    [*] --> ${actor.initial}\n`;
                }
                
                actor.transitions.forEach(t => {
                    let label = sanitizeMermaidLabel(toUnicodeLogic(t.label));
                    const prob = transitionProbabilities.get(transitionKey(t.from, t.label, t.to))
                        || transitionProbabilitiesByLabel.get(t.label);
                    if (prob) {
                        label = `${label} (${prob})`;
                    }
                    if (/^(send_|recv_)/.test(t.label)) {
                        const dest = actorFromState(t.to);
                        label = `${label} to ${dest}`;
                    }
                    code += `    ${t.from} --> ${t.to}: ${label}\n`;
                });
            });
            
            return code;
        }
        
        // Add this function and call it when spec loads:

        async function loadDocs() {
            try {
                const [resp, specResp] = await Promise.all([
                    fetch('/api/docs'),
                    fetch('/api/spec')
                ]);
                const data = await resp.json();
                const specData = await specResp.json();
                const actorsResp = await fetch('/api/actors');
                const actorsData = await actorsResp.json();
                
                const container = document.getElementById('docsContent');
                const docs = (data.success && data.docs) ? data.docs : [];
                const actors = (actorsData.success && actorsData.actors) ? actorsData.actors : [];
                const docsByTopic = new Map(docs.map(doc => [doc.topic, doc.content]));
                
                actorDescriptions.clear();
                const actorsByInitial = new Map();
                actors.forEach(actor => {
                    const roleKey = `role_${actor}`;
                    const actorKey = `actor_${actor}`;
                    const description = docsByTopic.get(roleKey) || docsByTopic.get(actorKey) || '';
                    if (description) {
                        actorDescriptions.set(actor, description);
                    }

                    const initial = actor.slice(0, 1);
                    if (!actorsByInitial.has(initial)) {
                        actorsByInitial.set(initial, []);
                    }
                    actorsByInitial.get(initial).push(actor);
                });

                for (const [initial, names] of actorsByInitial.entries()) {
                    if (names.length === 1) {
                        const onlyActor = names[0];
                        const description = actorDescriptions.get(onlyActor);
                        if (description && !actorDescriptions.has(initial)) {
                            actorDescriptions.set(initial, description);
                        }
                    }
                }
                
                updateSpecBanner(docs, specData);

                if (docs.length > 0) {
                    // Group docs by category based on topic prefix
                    const sections = {
                        'Overview': [],
                        'Roles': [],
                        'Phases': [],
                        'Safety': [],
                        'Visualizations': [],
                        'Other': []
                    };
                    
                    docs.forEach(doc => {
                        const topic = doc.topic || '';
                        if (topic === 'title' || topic === 'version' || topic === 'author' || topic === 'overview' || topic === 'description') {
                            sections['Overview'].push(doc);
                        } else if (topic.startsWith('role_')) {
                            sections['Roles'].push(doc);
                        } else if (topic.startsWith('phase')) {
                            sections['Phases'].push(doc);
                        } else if (topic.startsWith('safety_')) {
                            sections['Safety'].push(doc);
                        } else if (topic.startsWith('viz_')) {
                            sections['Visualizations'].push(doc);
                        } else {
                            sections['Other'].push(doc);
                        }
                    });
                    
                    let html = '';
                    
                    // Render Overview section specially
                    if (sections['Overview'].length > 0) {
                        const titleDoc = sections['Overview'].find(d => d.topic === 'title');
                        const versionDoc = sections['Overview'].find(d => d.topic === 'version');
                        const overviewDoc = sections['Overview'].find(d => d.topic === 'overview');
                        const descDoc = sections['Overview'].find(d => d.topic === 'description');
                        
                        html += `<div style="margin-bottom: 24px;">`;
                        if (titleDoc) {
                            html += `<h2 style="color: var(--accent-blue); margin: 0;">${titleDoc.content}</h2>`;
                        }
                        if (versionDoc) {
                            html += `<div style="color: var(--text-secondary); font-size: 0.85rem;">Version ${versionDoc.content}</div>`;
                        }
                        if (overviewDoc) {
                            html += `<p style="margin-top: 12px; color: var(--text-primary);">${overviewDoc.content}</p>`;
                        }
                        if (descDoc) {
                            html += `<p style="margin-top: 8px; color: var(--text-secondary);">${descDoc.content}</p>`;
                        }
                        html += `</div>`;
                    }
                    
                    if (actors.length > 0) {
                        html += '<div style="margin-bottom: 20px;">';
                        html += '<h3 style="color: var(--accent-purple); margin: 0 0 8px 0; font-size: 1rem;">Actors</h3>';
                        actors.forEach(actor => {
                            const roleKey = `role_${actor}`;
                            const actorKey = `actor_${actor}`;
                            const description = docsByTopic.get(roleKey) || docsByTopic.get(actorKey) || '';
                            const fallback = `Add doc(role_${actor}, '...') to describe intent.`;
                            html += `<div style="margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 4px;">`;
                            html += `<div style="font-weight: 500; color: var(--accent-blue); font-size: 0.9rem;">${actor}</div>`;
                            html += `<div style="color: var(--text-primary); font-size: 0.85rem; margin-top: 4px;">${description || fallback}</div>`;
                            html += `</div>`;
                        });
                        html += '</div>';
                    }
                    
                    // Render other sections
                    const sectionOrder = ['Roles', 'Phases', 'Safety', 'Visualizations', 'Other'];
                    for (const sectionName of sectionOrder) {
                        const docs = sections[sectionName];
                        if (docs.length === 0) continue;
                        
                        html += `<div style="margin-bottom: 20px;">`;
                        html += `<h3 style="color: var(--accent-purple); margin: 0 0 8px 0; font-size: 1rem;">${sectionName}</h3>`;
                        
                        docs.forEach(doc => {
                            // Clean up topic name for display
                            let displayTopic = doc.topic
                                .replace(/^(role_|phase|safety_|viz_)/, '')
                                .replace(/_/g, ' ')
                                .replace(/\b\w/g, c => c.toUpperCase());
                            
                            html += `<div style="margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 4px;">`;
                            html += `<div style="font-weight: 500; color: var(--accent-blue); font-size: 0.9rem;">${displayTopic}</div>`;
                            html += `<div style="color: var(--text-primary); font-size: 0.85rem; margin-top: 4px;">${doc.content}</div>`;
                            html += `</div>`;
                        });
                        
                        html += `</div>`;
                    }
                    
                    container.innerHTML = html;
                } else {
                    container.innerHTML = '<div style="color: var(--text-secondary);">No documentation in spec. Add doc(topic, content) facts.</div>';
                }
            } catch (err) {
                console.error('Error loading docs:', err);
            }
        }

        function updateSpecBanner(docs, specData) {
            const banner = document.getElementById('specBanner');
            if (!banner) {
                return;
            }
            const titleEl = banner.querySelector('.spec-title');
            const descEl = banner.querySelector('.spec-desc');
            const fileEl = banner.querySelector('.spec-file');

            const docMap = new Map((docs || []).map(doc => [doc.topic, doc.content]));
            const title = docMap.get('title') || 'Loaded Specification';
            const desc = docMap.get('overview') || docMap.get('description') || '';
            const file = (specData && specData.file) ? specData.file : '';
            const source = (specData && specData.source) ? specData.source.trim() : '';

            if (!source) {
                titleEl.textContent = 'No spec loaded';
                descEl.textContent = 'Load a Prolog specification to see system details.';
                fileEl.textContent = '';
                return;
            }

            titleEl.textContent = title;
            descEl.textContent = desc || 'This system is defined by the loaded Prolog specification.';
            fileEl.textContent = file ? `File: ${file}` : '';
        }
        
        async function loadPromptPreview() {
            try {
                const [promptResp, specResp] = await Promise.all([
                    fetch('/api/system-prompt'),
                    fetch('/api/spec')
                ]);
                const promptData = await promptResp.json();
                const specData = await specResp.json();
                
                const systemPrompt = document.getElementById('systemPromptText');
                const userPrompt = document.getElementById('userPromptText');
                const editorValue = document.getElementById('specEditor')?.value || '';
                const chatValue = document.getElementById('chatInput')?.value.trim() || '<your message>';
                
                systemPrompt.textContent = promptData.success ? promptData.prompt : 'No system prompt available.';
                
                let preview = '';
                const currentSpec = specData && specData.source ? specData.source : '';
                if (currentSpec) {
                    preview += 'Current specification:\n```prolog\n' + currentSpec + '\n```\n\n';
                }
                if (editorValue) {
                    preview += 'Context:\n' + editorValue + '\n\n';
                }
                preview += 'User request:\n' + chatValue;
                
                userPrompt.textContent = preview;
            } catch (err) {
                console.error('Error loading prompt preview:', err);
            }
        }
        
        // Update applySpec to also load docs
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                    loadDocs();  // Add this line
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        // Also load docs on page load
        // Add after loadProperties() call:
        loadProperties();
        loadDocs();
        loadPromptPreview();
    </script>
</body>
</html>
