<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turducken - Formal Methods in Prolog</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            font-size: 1.8rem;
            color: var(--accent-blue);
        }
        
        h1 span {
            color: var(--text-secondary);
            font-weight: normal;
            font-size: 1rem;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
        }
        
        .status-indicator.error {
            background: var(--accent-red);
        }
        
        .status-indicator.success {
            background: var(--accent-green);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 120px);
        }
        
        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .panel-body {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .tabs {
            display: flex;
            gap: 4px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .tab {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: var(--accent-blue);
            color: white;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .editor {
            flex: 1;
            min-height: 200px;
            resize: none;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }
        
        .btn-primary:hover {
            background: #4393e6;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--border-color);
        }
        
        .btn-success {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .output {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.85rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .output.success {
            border-color: var(--accent-green);
        }
        
        .output.error {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 12px;
            padding-right: 8px;
        }
        
        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .message.user {
            background: var(--bg-tertiary);
            margin-left: 40px;
        }
        
        .message.assistant {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            margin-right: 40px;
        }
        
        .message-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .chat-input-area {
            flex-shrink: 0;
        }
        
        .chat-input-area textarea {
            min-height: 80px;
        }
        
        .mermaid-output {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        
        .mermaid-output .mermaid {
            min-width: auto;
        }
        
        .mermaid-output svg {
            min-width: auto;
            min-height: auto;
            max-width: 100%;
        }
        
        .property-check {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .property-check input {
            flex: 1;
        }
        
        .check-result {
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .check-result.satisfied {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .check-result.unsatisfied {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .tab-content {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        pre code {
            display: block;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            overflow-x: auto;
        }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .help-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 8px;
        }
        
        .examples {
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .example-btn {
            font-size: 0.8rem;
            padding: 4px 8px;
            margin-right: 4px;
            margin-bottom: 4px;
        }
        
        .viz-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Turducken <span>Formal Methods in Prolog</span></h1>
            <div class="status">
                <select id="providerSelect" class="btn btn-secondary" style="padding: 4px 8px; font-size: 0.85rem;" onchange="switchProvider()">
                    <option value="openai">ChatGPT</option>
                    <option value="anthropic">Claude</option>
                </select>
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Ready</span>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Spec & Visualization -->
            <div class="panel">
                <!-- Add new tab button in the tabs div -->
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('viz')">üìä Visualize</button>
                    <button class="tab" onclick="switchTab('docs')">üìñ Docs</button>
                    <button class="tab" onclick="switchTab('spec')">üìù Prolog</button>
                    <button class="tab" onclick="switchTab('prompt')">üß≠ Sys Prompt</button>
                    <button class="tab" onclick="switchTab('query')">üîç Query</button>
                    <button class="tab" onclick="switchTab('check')">‚úì Check</button>
                </div>
                
                <!-- Visualize Tab -->
                <div id="tab-viz" class="tab-content active">
                    <div class="panel-body">
                        <div class="viz-buttons">
                            <button class="btn btn-secondary" onclick="visualize('sequence')">Sequence</button>
                            <button class="btn btn-secondary" onclick="visualize('statemachine')">State Machine</button>
                            <button class="btn btn-secondary" onclick="visualize('line')">Line Chart</button>
                            <button class="btn btn-secondary" onclick="visualize('pie')">Pie Chart</button>
                        </div>
                        <div id="actorSummary" style="margin-bottom: 12px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; border: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary);">Load a spec to see actor descriptions.</div>
                        </div>
                        <div id="vizOutput" class="mermaid-output">
                            <div style="color: var(--text-secondary); text-align: center;">
                                Select a visualization type above
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Prolog Spec Tab -->
                <div id="tab-spec" class="tab-content">
                    <div class="panel-body">
                        <textarea id="specEditor" class="editor" placeholder="% Enter your Prolog specification here...

% Example state machine:
state(idle, [waiting]).
state(busy, [processing]).
initial(idle).
transition(idle, start, busy).
transition(busy, done, idle).
"></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="applySpec()">Apply Spec</button>
                            <button class="btn btn-secondary" onclick="resetEngine()">Reset</button>
                        </div>
                        <div class="examples">
                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Examples: </span>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('mutex')">Mutex</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('channel')">Channel</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('sequence')">Sequence</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('yahalom')">Yahalom</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('needham_schroeder')">Needham-Schroeder</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('kerberos')">Kerberos</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('bread_company')">Bread Company</button>
                        </div>
                    </div>
                </div>
                
                <!-- System Prompt Tab -->
                <div id="tab-prompt" class="tab-content">
                    <div class="panel-body" style="overflow-y: auto; min-height: 0; flex: 1;">
                        <h4 style="margin: 0 0 8px 0; color: var(--text-secondary);">System Prompt</h4>
                        <pre id="systemPromptText" style="white-space: pre-wrap; margin: 0 0 16px 0; color: var(--text-primary);"></pre>
                        <h4 style="margin: 0 0 8px 0; color: var(--text-secondary);">User Prompt (preview)</h4>
                        <pre id="userPromptText" style="white-space: pre-wrap; margin: 0; color: var(--text-primary);"></pre>
                    </div>
                </div>
                
                <!-- Query Tab -->
                <div id="tab-query" class="tab-content">
                    <div class="panel-body">
                        <input type="text" id="queryInput" placeholder="Enter Prolog query (e.g., transition(X, Y, Z).)">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="runQuery()">Run Query</button>
                        </div>
                        <div class="help-text">
                            Try: <code>transition(X, _, Y).</code> or <code>initial(X).</code>
                        </div>
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-secondary);">Result:</h4>
                        <div id="queryOutput" class="output"></div>
                    </div>
                </div>
                
                <!-- Check Tab -->
                <div id="tab-check" class="tab-content">
                    <div class="panel-body">
                        <h4 style="margin: 0 0 12px 0; color: var(--text-primary);">Properties</h4>
                        <div id="propertyList" style="margin-bottom: 16px;">
                            <div style="color: var(--text-secondary);">Load a spec to see defined properties</div>
                        </div>
                        
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary);">Custom Check</h4>
                        <div class="property-check">
                            <input type="text" id="propertyInput" placeholder="CTL formula (e.g., ef(atom(done)))">
                            <button class="btn btn-primary" onclick="checkProperty()">Check</button>
                        </div>
                        <div class="help-text">
                            CTL operators: <code>ef</code>, <code>af</code>, <code>eg</code>, <code>ag</code>, <code>ex</code>, <code>ax</code>, <code>eu</code>, <code>au</code><br>
                            Combinators: <code>atom(p)</code>, <code>not(œÜ)</code>, <code>and(œÜ,œà)</code>, <code>or(œÜ,œà)</code>
                        </div>
                        <div id="checkResult"></div>
                    </div>
                </div>
                
                <!-- Docs Tab -->
                <div id="tab-docs" class="tab-content">
                    <div class="panel-body" style="overflow-y: auto; min-height: 0; flex: 1;">
                        <div id="docsContent" style="overflow-y: auto; height: 100%;">
                            <div style="color: var(--text-secondary);">Load a spec to see documentation</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Chat Only -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">üí¨ Chat</span>
                    <button class="btn btn-secondary" onclick="clearChat()" style="padding: 4px 12px;">Clear</button>
                </div>
                <div class="panel-body chat-container">
                    <div id="chatMessages" class="chat-messages">
                        <div class="message assistant">
                            <div class="message-label">Turducken</div>
                            Describe the system you want to model, and I'll generate a Prolog specification. 
                            You can ask me to model state machines, protocols, processes, or any system with temporal properties.
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <textarea id="chatInput" rows="3" placeholder="Describe your system or ask a question..."></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="sendChat()">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        // Initialize Mermaid with dark theme
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                darkMode: true,
                background: '#0d1117',
                primaryColor: '#58a6ff',
                primaryTextColor: '#e6edf3',
                primaryBorderColor: '#30363d',
                lineColor: '#8b949e',
                secondaryColor: '#21262d',
                tertiaryColor: '#161b22'
            }
        });
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            if (tabName === 'prompt') {
                loadPromptPreview();
            }
        }
        
        // API calls
        // Regular apply - no auto-fix
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                    loadDocs();  // Add this line
                    loadPromptPreview();
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        async function resetEngine() {
            try {
                await fetch('/api/reset', { method: 'POST' });
                setStatus('success', 'Reset complete');
            } catch (err) {
                setStatus('error', 'Reset failed');
            }
        }
        
        async function runQuery() {
            const query = document.getElementById('queryInput').value;
            const output = document.getElementById('queryOutput');
            
            if (!query) {
                output.textContent = 'Enter a query';
                return;
            }
            
            try {
                const resp = await fetch('/api/query', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await resp.json();
                
                output.className = 'output ' + (data.success ? 'success' : 'error');
                output.textContent = data.success ? data.result : 'Error: ' + data.error;
            } catch (err) {
                output.className = 'output error';
                output.textContent = 'Failed: ' + err.message;
            }
        }
        
        async function checkProperty() {
            const property = document.getElementById('propertyInput').value;
            const resultDiv = document.getElementById('checkResult');
            
            if (!property) {
                resultDiv.innerHTML = '';
                return;
            }
            
            try {
                const resp = await fetch('/api/check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ property })
                });
                const data = await resp.json();
                
                if (data.success) {
                    resultDiv.innerHTML = `<div class="check-result ${data.satisfied ? 'satisfied' : 'unsatisfied'}">
                        ${data.satisfied ? '‚úì Property SATISFIED' : '‚úó Property NOT satisfied'}
                    </div>`;
                } else {
                    resultDiv.innerHTML = `<div class="check-result unsatisfied">Error: ${data.error}</div>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<div class="check-result unsatisfied">Failed: ${err.message}</div>`;
            }
        }
        
        function setProperty(prop) {
            document.getElementById('propertyInput').value = prop;
        }
        
        async function sendChat() {
            const input = document.getElementById('chatInput');
            const messages = document.getElementById('chatMessages');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            messages.innerHTML += `<div class="message user">
                <div class="message-label">You</div>
                ${escapeHtml(message)}
            </div>`;
            
            input.value = '';
            messages.scrollTop = messages.scrollHeight;
            
            // Show loading
            const loadingId = 'loading-' + Date.now();
            messages.innerHTML += `<div id="${loadingId}" class="message assistant">
                <div class="message-label">Turducken</div>
                <div class="loading"></div> Thinking...
            </div>`;
            messages.scrollTop = messages.scrollHeight;
            
            try {
                const resp = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message,
                        context: document.getElementById('specEditor').value
                    })
                });
                const data = await resp.json();
                
                // Remove loading message
                document.getElementById(loadingId)?.remove();
                
                if (data.success) {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Turducken</div>
                        ${formatResponse(data.response)}
                    </div>`;
                    
                    // If there's Prolog code, auto-populate the editor
                    if (data.prolog) {
                        document.getElementById('specEditor').value = data.prolog;
                        
                        // Add apply button
                        messages.innerHTML += `<div class="message assistant" style="padding: 8px 12px;">
                            <button class="btn btn-success" onclick="applyAndVisualize()">
                                ‚úì Apply Spec & Visualize
                            </button>
                            <span style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 8px;">
                                Prolog populated in editor
                            </span>
                        </div>`;
                    }
                } else {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Error</div>
                        ${data.error}
                    </div>`;
                }
            } catch (err) {
                document.getElementById(loadingId)?.remove();
                messages.innerHTML += `<div class="message assistant">
                    <div class="message-label">Error</div>
                    ${err.message}
                </div>`;
            }
            
            messages.scrollTop = messages.scrollHeight;
        }
        
        async function applyAndVisualize() {
            await applySpec();
            switchTab('viz');
            visualize('sequence');
        }
        
        function clearChat() {
            document.getElementById('chatMessages').innerHTML = `<div class="message assistant">
                <div class="message-label">Turducken</div>
                Describe the system you want to model, and I'll generate a Prolog specification.
            </div>`;
        }
        
        async function visualize(type) {
            const output = document.getElementById('vizOutput');
            output.innerHTML = '<div class="loading"></div>';
            
            try {
                // Pie and Line show message traffic (from message/4 facts)
                if (type === 'pie' || type === 'line') {
                    const resp = await fetch('/api/visualize?type=sequence');
                    const data = await resp.json();
                    const messages = (data.sequence && data.sequence.messages) ? data.sequence.messages : [];
                    
                    if (messages.length === 0) {
                        output.innerHTML = '<div style="color: var(--text-secondary);">No messages to chart. Add message/4 facts.</div>';
                        return;
                    }
                    
                    if (type === 'pie') {
                        const counts = {};
                        messages.forEach(m => {
                            const key = m.from || 'unknown';
                            counts[key] = (counts[key] || 0) + 1;
                        });
                        
                        const slices = Object.entries(counts)
                            .map(([label, value]) => `    "${label}" : ${value}`)
                            .join('\n');
                        
                        output.innerHTML = `<pre class="mermaid">pie title Messages By Sender\n${slices}</pre>`;
                        await mermaid.run();
                        return;
                    } else if (type === 'line') {
                        const ordered = messages.map((m, idx) => ({
                            seq: (typeof m.seq === 'number' && !Number.isNaN(m.seq)) ? m.seq : idx + 1,
                            from: m.from || 'unknown'
                        })).sort((a, b) => a.seq - b.seq);
                        
                        const senders = new Set();
                        ordered.forEach(m => senders.add(m.from));
                        
                        const runningCounts = {};
                        const cumulativeBySender = new Map();
                        for (const sender of senders) {
                            runningCounts[sender] = 0;
                            cumulativeBySender.set(sender, []);
                        }
                        
                        const xValues = [];
                        ordered.forEach(evt => {
                            runningCounts[evt.from]++;
                            xValues.push(evt.seq);
                            
                            for (const [sender, arr] of cumulativeBySender) {
                                arr.push(runningCounts[sender]);
                            }
                        });
                        
                        if (xValues.length === 0) {
                            output.innerHTML = '<div style="color: var(--text-secondary);">No message data.</div>';
                            return;
                        }
                        
                        const maxPoints = 200;
                        let sampledX = xValues;
                        let sampledSeries = cumulativeBySender;
                        
                        if (xValues.length > maxPoints) {
                            const stride = Math.ceil(xValues.length / maxPoints);
                            const sampleIdx = [];
                            for (let i = 0; i < xValues.length; i += stride) {
                                sampleIdx.push(i);
                            }
                            
                            sampledX = sampleIdx.map(i => xValues[i]);
                            sampledSeries = new Map();
                            for (const [sender, values] of cumulativeBySender) {
                                sampledSeries.set(sender, sampleIdx.map(i => values[i]));
                            }
                        }
                        
                        const maxY = Math.max(...Object.values(runningCounts)) + 2;
                        const xAxis = sampledX.map(x => `"${x}"`).join(', ');
                        
                        let code = `xychart-beta
    title "Messages Over Sequence"
    x-axis "Seq" [${xAxis}]
    y-axis "Count" 0 --> ${maxY}`;
                        
                        for (const [sender, values] of sampledSeries) {
                            code += `\n    line [${values.join(', ')}]`;
                        }
                        
                        const series = Array.from(sampledSeries.keys()).map(name => ({ name }));
                        const legendHtml = generateLineLegend({ series });
                        output.innerHTML = `<pre class="mermaid">${code}</pre>${legendHtml}`;
                        try {
                            await mermaid.run();
                        } catch (mermaidErr) {
                            console.error('Mermaid error:', mermaidErr);
                            output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem;">${code}</pre>`;
                        }
                        return;
                    }
                }
                
                // State machine and sequence use Prolog visualization data
                const resp = await fetch(`/api/visualize?type=${type}`);
                const data = await resp.json();
                
                let mermaidCode = '';
                let noDataMessage = '';
                
                switch (type) {
                    case 'statemachine':
                        if (data.stateMachine && data.stateMachine.transitions) {
                            const actorMachines = groupTransitionsByActor(data.stateMachine);
                            if (Object.keys(actorMachines).length > 1) {
                                output.innerHTML = generateActorPanes(actorMachines);
                                await mermaid.run();
                                return;
                            }
                        }
                        mermaidCode = generateStateMachineMermaid(data.stateMachine);
                        break;
                    case 'sequence':
                        mermaidCode = generateSequenceMermaid(data.sequence);
                        if (!mermaidCode) {
                            noDataMessage = 'No sequence messages found. Add lifeline/1 and message/4 facts to your spec.';
                        }
                        break;
                }
                
                if (mermaidCode) {
                    output.innerHTML = `<pre class="mermaid">${mermaidCode}</pre>`;
                    try {
                        await mermaid.run();
                    } catch (mermaidErr) {
                        console.error('Mermaid error:', mermaidErr);
                        output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem;">${mermaidCode}</pre>`;
                    }
                } else {
                    output.innerHTML = `<div style="color: var(--text-secondary);">${noDataMessage || 'No data to visualize. Load a specification first.'}</div>`;
                }
            } catch (err) {
                output.innerHTML = `<div style="color: var(--accent-red);">Error: ${err.message}</div>`;
            }
        }
        
        function groupTransitionsByActor(sm) {
            const actors = {};
            
            // Dynamically extract prefixes from state names
            // Convention: states are named like "actorname_statename"
            const extractPrefix = (state) => {
                const idx = state.indexOf('_');
                if (idx > 0) {
                    return state.substring(0, idx + 1); // include underscore
                }
                return null;
            };
            
            // Build prefix map from all states we see
            const prefixToActor = new Map();
            
            sm.transitions.forEach(t => {
                [t.from, t.to].forEach(state => {
                    const prefix = extractPrefix(state);
                    if (prefix && !prefixToActor.has(prefix)) {
                        // Actor name is prefix without underscore
                        prefixToActor.set(prefix, prefix.slice(0, -1));
                    }
                });
            });
            
            sm.initial.forEach(s => {
                const prefix = extractPrefix(s);
                if (prefix && !prefixToActor.has(prefix)) {
                    prefixToActor.set(prefix, prefix.slice(0, -1));
                }
            });
            
            // Group transitions by actor
            sm.transitions.forEach(t => {
                const prefix = extractPrefix(t.from) || extractPrefix(t.to);
                if (!prefix) return;
                
                const actor = prefixToActor.get(prefix);
                if (!actor) return;
                
                if (!actors[actor]) {
                    actors[actor] = { transitions: [], initial: [] };
                }
                actors[actor].transitions.push(t);
            });
            
            // Add initial states
            sm.initial.forEach(s => {
                const prefix = extractPrefix(s);
                if (!prefix) return;
                
                const actor = prefixToActor.get(prefix);
                if (!actor) return;
                
                if (!actors[actor]) {
                    actors[actor] = { transitions: [], initial: [] };
                }
                actors[actor].initial.push(s);
            });
            
            return actors;
        }
        
        function generateActorPanes(actorMachines) {
            // Get actors in sorted order (no hardcoded list)
            const actorOrder = Object.keys(actorMachines).sort();
            
            let html = `<div style="
                display: flex; 
                flex-direction: column;
                gap: 16px; 
                overflow: auto;
                max-height: 100%;
                padding: 4px;
            ">`;
            
            for (const actor of actorOrder) {
                const sm = actorMachines[actor];
                if (!sm) continue;
                
                let code = 'stateDiagram-v2\n';
                code += `    direction LR\n`;
                
                sm.initial.forEach(s => {
                    code += `    [*] --> ${s}\n`;
                });
                
                sm.transitions.forEach(t => {
                    // No hardcoded annotations - just show the label
                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                });
                
                html += `
                    <div style="
                        background: var(--bg-tertiary); 
                        padding: 12px; 
                        border-radius: 6px;
                        min-height: 120px;
                        overflow-x: auto;
                    ">
                        <h4 style="margin: 0 0 8px 0; color: var(--accent-blue);">${actor}</h4>
                        <div style="overflow-x: auto; min-width: max-content;">
                            <pre class="mermaid" style="margin: 0;">${code}</pre>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            return html;
        }
        
        function generateStateMachineMermaid(data) {
            if (!data || !data.transitions || data.transitions.length === 0) {
                return null;
            }
            
            let code = 'stateDiagram-v2\n';
            
            if (data.initial && data.initial.length > 0) {
                data.initial.forEach(s => {
                    code += `    [*] --> ${s}\n`;
                });
            }
            
            if (data.transitions) {
                data.transitions.forEach(t => {
                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                });
            }
            
            if (data.accepting && data.accepting.length > 0) {
                data.accepting.forEach(s => {
                    code += `    ${s} --> [*]\n`;
                });
            }
            
            return code;
        }
        
        function generateSequenceMermaid(data) {
            if (!data || !data.messages || data.messages.length === 0) {
                return null;
            }
            
            let code = 'sequenceDiagram\n';
            
            if (data.lifelines) {
                data.lifelines.forEach(l => {
                    code += `    participant ${l}\n`;
                });
            }
            
            if (data.messages) {
                data.messages.forEach(m => {
                    code += `    ${m.from}->>${m.to}: ${m.label}\n`;
                });
            }
            
            return code;
        }
        
        function generatePieMermaid(data) {
            if (!data || !data.slices || data.slices.length === 0) {
                return null;
            }
            
            let code = 'pie title Request Distribution\n';
            data.slices.forEach(s => {
                code += `    "${s.label}" : ${s.value}\n`;
            });
            return code;
        }
        
        function generateLineMermaid(data) {
            if (!data || !data.series || data.series.length === 0) {
                return null;
            }
            
            const allXValues = new Set();
            data.series.forEach(series => {
                if (series.points) {
                    series.points.forEach(p => allXValues.add(p.x));
                }
            });
            
            if (allXValues.size === 0) {
                return null;
            }
            
            const sortedX = [...allXValues].sort((a, b) => a - b);
            const xValues = sortedX.map(x => `"${x}"`).join(', ');
            
            let maxY = 0;
            data.series.forEach(series => {
                if (series.points) {
                    series.points.forEach(p => {
                        if (p.y > maxY) maxY = p.y;
                    });
                }
            });
            maxY += 5;
            
            let code = `xychart-beta
    title "Metrics Over Time"
    x-axis [${xValues}]
    y-axis "Value" 0 --> ${maxY}`;
            
            data.series.forEach(series => {
                if (series.points && series.points.length > 0) {
                    const pointMap = new Map();
                    series.points.forEach(p => pointMap.set(p.x, p.y));
                    const yValues = sortedX.map(x => pointMap.has(x) ? pointMap.get(x) : 0).join(', ');
                    code += `\n    line [${yValues}]`;
                }
            });
            
            return code;
        }
        
        // Generate legend HTML for line chart
        function generateLineLegend(data) {
            if (!data || !data.series || data.series.length === 0) {
                return '';
            }
            
            const colors = ['#58a6ff', '#3fb950', '#f85149', '#d29922', '#a371f7', '#f778ba'];
            
            let html = '<div style="display: flex; flex-wrap: wrap; gap: 16px; margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">';
            data.series.forEach((series, i) => {
                const color = colors[i % colors.length];
                html += `<div style="display: flex; align-items: center; gap: 6px;">
                    <div style="width: 20px; height: 3px; background: ${color};"></div>
                    <span style="color: var(--text-secondary); font-size: 0.85rem;">${series.name}</span>
                </div>`;
            });
            html += '</div>';
            return html;
        }
        
        // Example specifications
        const examples = {
            mutex: `% Mutual Exclusion Protocol
                state(free, [available]).
                state(locked, [busy]).
                
                initial(free).
                
                transition(free, acquire, locked).
                transition(locked, release, free).
                
                prop(free, available).
                prop(locked, busy).
                
                property(no_deadlock, 'Can always release', 'ag(ef(atom(available)))').`,
                
            channel: `% Buffered Channel (CSP style)
                state(empty, [can_send]).
                state(has_one, [can_send, can_recv]).
                state(full, [can_recv]).
                
                initial(empty).
                
                transition(empty, send, has_one).
                transition(has_one, send, full).
                transition(full, recv, has_one).
                transition(has_one, recv, empty).
                
                prop(empty, can_send).
                prop(has_one, can_send).
                prop(has_one, can_recv).
                prop(full, can_recv).
                
                property(liveness, 'Can always send again', 'ag(ef(atom(can_send)))').`,
                
            sequence: `% Request-Response Protocol
                channel(client_server, 1).
                channel(server_db, 1).
                
                send(client_server, request, client_idle, client_waiting).
                send(server_db, query, server_requesting, server_querying).
                send(server_db, result, database_querying, database_idle).
                send(client_server, response, server_responding, server_idle).
                
                recv(client_server, request, server_idle, server_requesting).
                recv(server_db, query, database_idle, database_querying).
                recv(server_db, result, server_querying, server_responding).
                recv(client_server, response, client_waiting, client_idle).
                
                actor(client).
                actor(server).
                actor(database).
                
                actor_initial(client, client_idle).
                actor_initial(server, server_idle).
                actor_initial(database, database_idle).
                
                actor_state(client, client_idle, [ready]).
                actor_state(client, client_waiting, [busy]).
                actor_state(server, server_idle, [ready]).
                actor_state(server, server_requesting, [busy]).
                actor_state(server, server_querying, [busy]).
                actor_state(server, server_responding, [busy]).
                actor_state(database, database_idle, [ready]).
                actor_state(database, database_querying, [busy]).
                
                actor_transition(client, client_idle, request, client_waiting).
                actor_transition(client, client_waiting, response, client_idle).
                actor_transition(server, server_idle, request, server_requesting).
                actor_transition(server, server_requesting, query, server_querying).
                actor_transition(server, server_querying, result, server_responding).
                actor_transition(server, server_responding, response, server_idle).
                actor_transition(database, database_idle, query, database_querying).
                actor_transition(database, database_querying, result, database_idle).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(completes, 'Requests complete', 'ag(or(not(atom(busy)), af(atom(ready))))').`
                ,
            bread_company: `% Bread Company Operations
                doc(title, 'Bread Company Operations').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'A bread company with production, logistics, retail, and customer demand.').
                doc(description, 'Actors communicate via messages. Production and customer arrivals are probabilistic chance nodes. Pie/line charts should visualize message volume by sender.').
                
                doc(role_factory, 'Factory mixes, kneads, bakes, cools, and bags bread.').
                doc(role_bakers, 'Bakers operate machines, knead dough, and manage oven loads.').
                doc(role_truck, 'Truck loads bagged bread and delivers to the storefront.').
                doc(role_storefront, 'Storefront receives bread, stocks racks, sells to customers, and manages aging inventory.').
                doc(role_customers, 'Customers arrive stochastically and buy bread from the fresh rack.').
                doc(role_charity, 'Charity rack receives bread older than 3 days.').
                doc(role_accounting, 'Accounting tracks wages, revenue, and profitability.').
                
                doc(viz_statemachine, 'State machines show operational modes per actor. Chance states model probabilistic events.').
                doc(viz_sequence, 'Sequence diagram shows a typical day: production -> delivery -> stocking -> customer sales -> accounting updates.').
                doc(viz_pie, 'Pie chart shows message volume by sender (actor).').
                doc(viz_line, 'Line chart shows cumulative messages by sender over sequence order.').
                
                actor(factory).
                actor(bakers).
                actor(truck).
                actor(storefront).
                actor(customers).
                actor(charity).
                actor(accounting).
                
                actor_initial(factory, factory_idle).
                actor_initial(bakers, bakers_idle).
                actor_initial(truck, truck_idle).
                actor_initial(storefront, store_closed).
                actor_initial(customers, customers_idle).
                actor_initial(charity, charity_idle).
                actor_initial(accounting, accounting_break_even).
                
                actor_state(factory, factory_idle, [ready]).
                actor_state(factory, factory_chance_batch, [chance]).
                actor_state(factory, factory_mixing, [in_progress]).
                actor_state(factory, factory_kneading, [in_progress]).
                actor_state(factory, factory_baking, [in_progress]).
                actor_state(factory, factory_cooling, [in_progress]).
                actor_state(factory, factory_bagging, [bagged_stock]).
                actor_state(factory, factory_waiting_truck, [bagged_stock]).
                
                actor_state(bakers, bakers_idle, [available]).
                actor_state(bakers, bakers_running_mixer, [busy]).
                actor_state(bakers, bakers_kneading, [busy]).
                actor_state(bakers, bakers_loading_oven, [busy]).
                actor_state(bakers, bakers_unloading_oven, [busy]).
                
                actor_state(truck, truck_idle, [available]).
                actor_state(truck, truck_loading, [busy]).
                actor_state(truck, truck_in_transit, [busy]).
                actor_state(truck, truck_unloading, [busy]).
                
                actor_state(storefront, store_closed, [closed]).
                actor_state(storefront, store_open, [open]).
                actor_state(storefront, store_stocking, [open]).
                actor_state(storefront, store_fresh_rack_full, [fresh_stock]).
                actor_state(storefront, store_fresh_rack_low, [fresh_stock, low_stock]).
                actor_state(storefront, store_charity_rack, [has_charity_stock]).
                actor_state(storefront, store_rotating_stock, [aging_stock]).
                actor_state(storefront, store_sold_out, [no_stock]).
                
                actor_state(customers, customers_idle, [chance]).
                actor_state(customers, customers_arriving_low, [arriving]).
                actor_state(customers, customers_arriving_high, [arriving]).
                actor_state(customers, customers_buying, [buying]).
                
                actor_state(charity, charity_idle, [ready]).
                actor_state(charity, charity_receiving, [receiving]).
                actor_state(charity, charity_stocked, [has_stock]).
                
                actor_state(accounting, accounting_break_even, [neutral]).
                actor_state(accounting, accounting_profitable, [profitable]).
                actor_state(accounting, accounting_loss, [loss]).
                actor_state(accounting, accounting_payroll, [wages_due]).
                actor_state(accounting, accounting_revenue, [revenue_in]).
                
                actor_transition(factory, factory_idle, start_day, factory_chance_batch).
                actor_transition(factory, factory_chance_batch, batch_low, factory_mixing).
                actor_transition(factory, factory_chance_batch, batch_high, factory_mixing).
                actor_transition(factory, factory_mixing, mixed, factory_kneading).
                actor_transition(factory, factory_kneading, kneaded, factory_baking).
                actor_transition(factory, factory_baking, baked, factory_cooling).
                actor_transition(factory, factory_cooling, cooled, factory_bagging).
                actor_transition(factory, factory_bagging, bagged, factory_waiting_truck).
                actor_transition(factory, factory_waiting_truck, loaded, factory_idle).
                
                actor_transition(bakers, bakers_idle, run_mixer, bakers_running_mixer).
                actor_transition(bakers, bakers_running_mixer, dough_ready, bakers_kneading).
                actor_transition(bakers, bakers_kneading, dough_kneaded, bakers_loading_oven).
                actor_transition(bakers, bakers_loading_oven, oven_loaded, bakers_unloading_oven).
                actor_transition(bakers, bakers_unloading_oven, oven_unloaded, bakers_idle).
                
                actor_transition(truck, truck_idle, arrive_factory, truck_loading).
                actor_transition(truck, truck_loading, loaded_truck, truck_in_transit).
                actor_transition(truck, truck_in_transit, arrive_store, truck_unloading).
                actor_transition(truck, truck_unloading, unloaded_store, truck_idle).
                
                actor_transition(storefront, store_closed, open_store, store_open).
                actor_transition(storefront, store_open, receive_delivery, store_stocking).
                actor_transition(storefront, store_stocking, racks_full, store_fresh_rack_full).
                actor_transition(storefront, store_fresh_rack_full, sell_bread, store_fresh_rack_low).
                actor_transition(storefront, store_fresh_rack_low, sell_out, store_sold_out).
                actor_transition(storefront, store_fresh_rack_low, restock, store_fresh_rack_full).
                actor_transition(storefront, store_fresh_rack_full, rotate_stock, store_rotating_stock).
                actor_transition(storefront, store_rotating_stock, moved_to_charity, store_charity_rack).
                actor_transition(storefront, store_charity_rack, charity_rack_set, store_open).
                actor_transition(storefront, store_sold_out, close_store, store_closed).
                
                actor_transition(customers, customers_idle, chance_arrival, customers_arriving_low).
                actor_transition(customers, customers_idle, chance_arrival_peak, customers_arriving_high).
                actor_transition(customers, customers_arriving_low, browse, customers_buying).
                actor_transition(customers, customers_arriving_high, rush, customers_buying).
                actor_transition(customers, customers_buying, checkout, customers_idle).
                
                actor_transition(charity, charity_idle, notify_pickup, charity_receiving).
                actor_transition(charity, charity_receiving, stocked, charity_stocked).
                actor_transition(charity, charity_stocked, clear_rack, charity_idle).
                
                actor_transition(accounting, accounting_break_even, record_wages, accounting_payroll).
                actor_transition(accounting, accounting_payroll, wages_paid, accounting_loss).
                actor_transition(accounting, accounting_loss, record_sales, accounting_revenue).
                actor_transition(accounting, accounting_revenue, profit_high, accounting_profitable).
                actor_transition(accounting, accounting_revenue, profit_low, accounting_break_even).
                actor_transition(accounting, accounting_profitable, record_wages, accounting_payroll).
                
                msg_annotation(start_day, send, bakers).
                msg_annotation(mixed, send, bakers).
                msg_annotation(kneaded, send, bakers).
                msg_annotation(baked, send, bakers).
                msg_annotation(cooled, send, bakers).
                msg_annotation(bagged, send, truck).
                msg_annotation(loaded_truck, send, truck).
                msg_annotation(arrive_store, send, storefront).
                msg_annotation(receive_delivery, recv, truck).
                msg_annotation(sell_bread, recv, customers).
                msg_annotation(checkout, send, accounting).
                msg_annotation(moved_to_charity, send, charity).
                
                channel(factory_bakers, 1).
                channel(factory_truck, 1).
                channel(truck_store, 1).
                channel(store_customers, 1).
                channel(store_accounting, 1).
                channel(store_charity, 1).
                
                send(factory_bakers, start_day, factory_idle, factory_chance_batch).
                send(factory_bakers, mixed, bakers_running_mixer, bakers_kneading).
                send(factory_bakers, kneaded, bakers_kneading, bakers_loading_oven).
                send(factory_bakers, baked, bakers_loading_oven, bakers_unloading_oven).
                send(factory_bakers, cooled, bakers_unloading_oven, bakers_idle).
                
                send(factory_truck, bagged, factory_bagging, factory_waiting_truck).
                send(factory_truck, loaded_truck, truck_loading, truck_in_transit).
                
                send(truck_store, deliver_bread, truck_in_transit, truck_unloading).
                send(truck_store, receive_delivery, store_stocking, store_fresh_rack_full).
                
                send(store_customers, arrive, customers_idle, customers_arriving_low).
                send(store_customers, offer_bread, store_fresh_rack_full, store_fresh_rack_low).
                send(store_customers, purchase_8, customers_buying, customers_idle).
                
                send(store_accounting, record_sale, store_fresh_rack_low, store_fresh_rack_low).
                
                send(store_charity, move_old_stock, store_rotating_stock, store_charity_rack).
                
                recv(factory_bakers, start_day, bakers_idle, bakers_running_mixer).
                recv(factory_bakers, mixed, factory_mixing, factory_kneading).
                recv(factory_bakers, kneaded, factory_kneading, factory_baking).
                recv(factory_bakers, baked, factory_baking, factory_cooling).
                recv(factory_bakers, cooled, factory_cooling, factory_bagging).
                
                recv(factory_truck, bagged, truck_idle, truck_loading).
                recv(factory_truck, loaded_truck, factory_waiting_truck, factory_idle).
                
                recv(truck_store, deliver_bread, store_open, store_stocking).
                recv(truck_store, receive_delivery, truck_unloading, truck_idle).
                
                recv(store_customers, arrive, store_open, store_open).
                recv(store_customers, offer_bread, customers_arriving_low, customers_buying).
                recv(store_customers, purchase_8, store_fresh_rack_low, store_fresh_rack_low).
                
                recv(store_accounting, record_sale, accounting_loss, accounting_revenue).
                
                recv(store_charity, move_old_stock, charity_idle, charity_receiving).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(profitable_eventually, 'Business can reach profitability', 'ag(ef(atom(profitable)))').
                property(avoid_permanent_stockout, 'Fresh rack not permanently empty', 'ag(ef(atom(fresh_stock)))').
                property(charity_receives_old_stock, 'Old stock eventually moved to charity', 'ag(ef(atom(has_charity_stock)))').
                property(wages_recorded, 'Payroll is eventually recorded', 'ag(ef(atom(wages_due)))').
                property(open_store_reachable, 'Store can open from initial conditions', 'ag(ef(atom(open)))').`
                ,
            yahalom: `% Yahalom Key Exchange Protocol
                doc(title, 'Yahalom Protocol').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'Three-party key exchange protocol with a trusted server.').
                doc(description, 'Actors A and B use server S to establish a shared session key Kab.').
                
                doc(role_initiator, 'A initiates the run by sending a fresh nonce to B.').
                doc(role_responder, 'B responds and relays A and fresh nonces to S.').
                doc(role_server, 'S creates a session key and returns tickets for A and B.').
                doc(role_attacker, 'Attacker can steal tickets or forge them after compromising S.').
                
                doc(viz_sequence, 'Sequence is derived from send/recv on channels.').
                doc(viz_statemachine, 'Explicit actor states make the protocol easy to diagram.').
                
                actor(a).
                actor(b).
                actor(s).
                actor(attacker).
                
                actor_initial(a, a_idle).
                actor_initial(b, b_idle).
                actor_initial(s, s_idle).
                actor_initial(attacker, attacker_idle).
                
                actor_state(a, a_idle, [ready]).
                actor_state(a, a_sent_na, [waiting]).
                actor_state(a, a_got_ticket, [has_ticket]).
                actor_state(a, a_established, [kab_established]).
                
                actor_state(b, b_idle, [ready]).
                actor_state(b, b_got_na, [waiting]).
                actor_state(b, b_sent_to_s, [waiting]).
                actor_state(b, b_established, [kab_established]).
                
                actor_state(s, s_idle, [ready]).
                actor_state(s, s_received, [processing]).
                actor_state(s, s_responded, [responded]).
                
                actor_state(attacker, attacker_idle, [ready]).
                actor_state(attacker, attacker_got_ticket, [attacker_has_ticket]).
                actor_state(attacker, attacker_got_kab, [attacker_has_kab]).
                actor_state(attacker, attacker_compromised, [attacker_can_forge]).
                
                actor_transition(a, a_idle, send_ab_na, a_sent_na).
                actor_transition(a, a_sent_na, recv_s_to_a, a_got_ticket).
                actor_transition(a, a_got_ticket, send_ticket_to_b, a_established).
                
                actor_transition(b, b_idle, recv_ab_na, b_got_na).
                actor_transition(b, b_got_na, send_to_s, b_sent_to_s).
                actor_transition(b, b_sent_to_s, recv_a_ticket, b_established).
                
                actor_transition(s, s_idle, recv_b_to_s, s_received).
                actor_transition(s, s_received, send_s_to_a, s_responded).
                actor_transition(s, s_responded, reset, s_idle).
                
                actor_transition(attacker, attacker_idle, steal_ticket, attacker_got_ticket).
                actor_transition(attacker, attacker_got_ticket, use_ticket, attacker_got_kab).
                actor_transition(attacker, attacker_idle, compromise_s, attacker_compromised).
                actor_transition(attacker, attacker_compromised, forge_ticket, attacker_got_ticket).
                
                channel(a_b, 1).
                channel(b_s, 1).
                channel(s_a, 1).
                channel(a_b_ticket, 1).
                
                message_format(na, 'A,Na').
                message_format(a_na_nb, 'A,Na,Nb').
                message_format(kab_ticket, 'Kab,ticket_b,Nb').
                
                send(a_b, na, a_idle, a_sent_na).
                send(b_s, a_na_nb, b_got_na, b_sent_to_s).
                send(s_a, kab_ticket, s_received, s_responded).
                send(a_b_ticket, kab_ticket, a_got_ticket, a_established).
                
                recv(a_b, na, b_idle, b_got_na).
                recv(b_s, a_na_nb, s_idle, s_received).
                recv(s_a, kab_ticket, a_sent_na, a_got_ticket).
                recv(a_b_ticket, kab_ticket, b_sent_to_s, b_established).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(a_establishes_key, 'A can establish Kab', 'ag(ef(atom(kab_established)))').
                property(b_establishes_key, 'B can establish Kab', 'ag(ef(atom(kab_established)))').
                property(attacker_can_get_ticket, 'Attacker can obtain a ticket', 'ef(atom(attacker_has_ticket))').
                property(attacker_can_get_kab, 'Attacker can obtain Kab', 'ef(atom(attacker_has_kab))').
                property(attacker_never_gets_kab, 'Attacker never learns Kab', 'ag(not(atom(attacker_has_kab)))').`
                ,
            needham_schroeder: `% Needham-Schroeder (Symmetric Key) Protocol
                doc(title, 'Needham-Schroeder (Symmetric Key)').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'A and B use a trusted server S to establish a session key Kab.').
                doc(description, 'Sequence derived from send/recv on channels.').
                
                doc(role_initiator, 'A initiates by requesting a session key for B.').
                doc(role_responder, 'B completes challenge-response with A.').
                doc(role_server, 'S issues Kab and a ticket for B.').
                doc(role_attacker, 'Attacker can steal tickets or forge them after compromising S.').
                
                actor(a).
                actor(b).
                actor(s).
                actor(attacker).
                
                actor_initial(a, a_idle).
                actor_initial(b, b_idle).
                actor_initial(s, s_idle).
                actor_initial(attacker, attacker_idle).
                
                actor_state(a, a_idle, [ready]).
                actor_state(a, a_sent_req, [waiting]).
                actor_state(a, a_got_ticket, [has_ticket]).
                actor_state(a, a_sent_ticket, [waiting]).
                actor_state(a, a_established, [kab_established]).
                
                actor_state(b, b_idle, [ready]).
                actor_state(b, b_got_ticket, [has_ticket]).
                actor_state(b, b_sent_nb, [waiting]).
                actor_state(b, b_established, [kab_established]).
                
                actor_state(s, s_idle, [ready]).
                actor_state(s, s_received, [processing]).
                actor_state(s, s_responded, [responded]).
                
                actor_state(attacker, attacker_idle, [ready]).
                actor_state(attacker, attacker_got_ticket, [attacker_has_ticket]).
                actor_state(attacker, attacker_got_kab, [attacker_has_kab]).
                actor_state(attacker, attacker_compromised, [attacker_can_forge]).
                
                actor_transition(a, a_idle, send_req, a_sent_req).
                actor_transition(a, a_sent_req, recv_ticket, a_got_ticket).
                actor_transition(a, a_got_ticket, send_ticket, a_sent_ticket).
                actor_transition(a, a_sent_ticket, recv_nb, a_established).
                
                actor_transition(b, b_idle, recv_ticket, b_got_ticket).
                actor_transition(b, b_got_ticket, send_nb, b_sent_nb).
                actor_transition(b, b_sent_nb, recv_nb_ack, b_established).
                
                actor_transition(s, s_idle, recv_req, s_received).
                actor_transition(s, s_received, send_ticket, s_responded).
                actor_transition(s, s_responded, reset, s_idle).
                
                actor_transition(attacker, attacker_idle, steal_ticket, attacker_got_ticket).
                actor_transition(attacker, attacker_got_ticket, use_ticket, attacker_got_kab).
                actor_transition(attacker, attacker_idle, compromise_s, attacker_compromised).
                actor_transition(attacker, attacker_compromised, forge_ticket, attacker_got_ticket).
                
                channel(a_s, 1).
                channel(s_a, 1).
                channel(a_b, 1).
                channel(b_a, 1).
                
                message_format(req_ab_na, 'A,B,Na').
                message_format(ticket_kab, 'Kab,ticket_b').
                message_format(nb, 'Nb').
                message_format(nb_ack, 'Nb-1').
                
                send(a_s, req_ab_na, a_idle, a_sent_req).
                send(s_a, ticket_kab, s_received, s_responded).
                send(a_b, ticket_kab, a_got_ticket, a_sent_ticket).
                send(b_a, nb, b_got_ticket, b_sent_nb).
                send(a_b, nb_ack, a_sent_ticket, a_established).
                
                recv(a_s, req_ab_na, s_idle, s_received).
                recv(s_a, ticket_kab, a_sent_req, a_got_ticket).
                recv(a_b, ticket_kab, b_idle, b_got_ticket).
                recv(b_a, nb, a_sent_ticket, a_established).
                recv(a_b, nb_ack, b_sent_nb, b_established).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(a_establishes_key, 'A can establish Kab', 'ag(ef(atom(kab_established)))').
                property(b_establishes_key, 'B can establish Kab', 'ag(ef(atom(kab_established)))').
                property(attacker_can_get_ticket, 'Attacker can obtain a ticket', 'ef(atom(attacker_has_ticket))').
                property(attacker_can_get_kab, 'Attacker can obtain Kab', 'ef(atom(attacker_has_kab))').
                property(attacker_never_gets_kab, 'Attacker never learns Kab', 'ag(not(atom(attacker_has_kab)))').`
                ,
            kerberos: `% Kerberos (Simplified)
                doc(title, 'Kerberos (Simplified)').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'Client obtains tickets from AS and TGS to access a service.').
                doc(description, 'Sequence derived from send/recv on channels.').
                
                doc(role_client, 'Client requests tickets and authenticates to the service.').
                doc(role_as, 'Authentication Server issues a TGT.').
                doc(role_tgs, 'Ticket Granting Server issues service tickets.').
                doc(role_service, 'Service accepts the client ticket.').
                doc(role_attacker, 'Attacker can steal tickets or forge them after compromising TGS.').
                
                actor(client).
                actor(as).
                actor(tgs).
                actor(service).
                actor(attacker).
                
                actor_initial(client, c_idle).
                actor_initial(as, as_idle).
                actor_initial(tgs, tgs_idle).
                actor_initial(service, s_idle).
                actor_initial(attacker, attacker_idle).
                
                actor_state(client, c_idle, [ready]).
                actor_state(client, c_sent_as_req, [waiting]).
                actor_state(client, c_got_tgt, [has_tgt]).
                actor_state(client, c_sent_tgs_req, [waiting]).
                actor_state(client, c_got_svc_ticket, [has_ticket]).
                actor_state(client, c_authenticated, [authed]).
                
                actor_state(as, as_idle, [ready]).
                actor_state(as, as_received, [processing]).
                actor_state(as, as_responded, [responded]).
                
                actor_state(tgs, tgs_idle, [ready]).
                actor_state(tgs, tgs_received, [processing]).
                actor_state(tgs, tgs_responded, [responded]).
                
                actor_state(service, s_idle, [ready]).
                actor_state(service, s_received, [processing]).
                actor_state(service, s_accepted, [authed]).
                
                actor_state(attacker, attacker_idle, [ready]).
                actor_state(attacker, attacker_got_tgt, [attacker_has_tgt]).
                actor_state(attacker, attacker_got_ticket, [attacker_has_ticket]).
                actor_state(attacker, attacker_authed, [attacker_authed]).
                actor_state(attacker, attacker_compromised, [attacker_can_forge]).
                
                actor_transition(client, c_idle, send_as_req, c_sent_as_req).
                actor_transition(client, c_sent_as_req, recv_as_rep, c_got_tgt).
                actor_transition(client, c_got_tgt, send_tgs_req, c_sent_tgs_req).
                actor_transition(client, c_sent_tgs_req, recv_tgs_rep, c_got_svc_ticket).
                actor_transition(client, c_got_svc_ticket, send_ap_req, c_authenticated).
                
                actor_transition(as, as_idle, recv_as_req, as_received).
                actor_transition(as, as_received, send_as_rep, as_responded).
                actor_transition(as, as_responded, reset, as_idle).
                
                actor_transition(tgs, tgs_idle, recv_tgs_req, tgs_received).
                actor_transition(tgs, tgs_received, send_tgs_rep, tgs_responded).
                actor_transition(tgs, tgs_responded, reset, tgs_idle).
                
                actor_transition(service, s_idle, recv_ap_req, s_received).
                actor_transition(service, s_received, send_ap_rep, s_accepted).
                actor_transition(service, s_accepted, reset, s_idle).
                
                actor_transition(attacker, attacker_idle, steal_tgt, attacker_got_tgt).
                actor_transition(attacker, attacker_got_tgt, use_tgt, attacker_got_ticket).
                actor_transition(attacker, attacker_idle, steal_ticket, attacker_got_ticket).
                actor_transition(attacker, attacker_got_ticket, use_ticket, attacker_authed).
                actor_transition(attacker, attacker_idle, compromise_tgs, attacker_compromised).
                actor_transition(attacker, attacker_compromised, forge_ticket, attacker_got_ticket).
                
                channel(c_as, 1).
                channel(as_c, 1).
                channel(c_tgs, 1).
                channel(tgs_c, 1).
                channel(c_svc, 1).
                channel(svc_c, 1).
                
                message_format(as_req, 'C').
                message_format(as_rep, 'TGT,Kc_tgs').
                message_format(tgs_req, 'TGT,Auth').
                message_format(tgs_rep, 'SvcTicket,Kc_svc').
                message_format(ap_req, 'SvcTicket,Auth').
                message_format(ap_rep, 'Ack').
                
                send(c_as, as_req, c_idle, c_sent_as_req).
                send(as_c, as_rep, as_received, as_responded).
                send(c_tgs, tgs_req, c_got_tgt, c_sent_tgs_req).
                send(tgs_c, tgs_rep, tgs_received, tgs_responded).
                send(c_svc, ap_req, c_got_svc_ticket, c_authenticated).
                send(svc_c, ap_rep, s_received, s_accepted).
                
                recv(c_as, as_req, as_idle, as_received).
                recv(as_c, as_rep, c_sent_as_req, c_got_tgt).
                recv(c_tgs, tgs_req, tgs_idle, tgs_received).
                recv(tgs_c, tgs_rep, c_sent_tgs_req, c_got_svc_ticket).
                recv(c_svc, ap_req, s_idle, s_received).
                recv(svc_c, ap_rep, c_authenticated, c_authenticated).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(client_authenticates, 'Client can authenticate to service', 'ag(ef(atom(authed)))').
                property(attacker_can_get_ticket, 'Attacker can obtain a service ticket', 'ef(atom(attacker_has_ticket))').
                property(attacker_can_authenticate, 'Attacker can authenticate to service', 'ef(atom(attacker_authed))').
                property(attacker_never_authenticates, 'Attacker never authenticates', 'ag(not(atom(attacker_authed)))').`
        };
        
        function loadExample(name) {
            document.getElementById('specEditor').value = examples[name];
            switchTab('spec');
        }
        
        const MAX_AUTO_FIX_RETRIES = 3;
        
        async function loadProperties() {
            try {
                const resp = await fetch('/api/properties');
                const data = await resp.json();
                
                const listDiv = document.getElementById('propertyList');
                if (data.success && data.properties && data.properties.length > 0) {
                    listDiv.innerHTML = data.properties.map(p => {
                        let statusIcon = '';
                        let statusColor = '';
                        if (p.error) {
                            statusIcon = '‚ö†Ô∏è';
                            statusColor = 'var(--accent-yellow)';
                        } else if (p.satisfied === true) {
                            statusIcon = '‚úì';
                            statusColor = 'var(--accent-green)';
                        } else if (p.satisfied === false) {
                            statusIcon = '‚úó';
                            statusColor = 'var(--accent-red)';
                        }
                        
                        return `
                        <div style="margin-bottom: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="color: ${statusColor}; font-size: 1.2rem;">${statusIcon}</span>
                                <strong style="color: var(--accent-blue);">${p.name}</strong>
                            </div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-left: 28px;">${p.description}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-purple); margin-left: 28px; font-family: monospace;">${p.formula}</div>
                            ${p.error ? `<div style="font-size: 0.8rem; color: var(--accent-red); margin-left: 28px;">Error: ${p.error}</div>` : ''}
                        </div>
                    `}).join('');
                } else {
                    listDiv.innerHTML = '<div style="color: var(--text-secondary);">No properties defined in spec</div>';
                }
            } catch (err) {
                console.error('Error loading properties:', err);
            }
        }
        
        async function checkNamedProperty(name, formula) {
            document.getElementById('propertyInput').value = formula;
            await checkProperty();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function formatResponse(text) {
            // Simple markdown-like formatting
            return escapeHtml(text)
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }
        
        // Initialize on page load
        loadProperties();
        loadDocs();
        
        window.addEventListener('load', () => {
            document.getElementById('vizOutput').innerHTML = '<div style="color: var(--text-secondary);">Select a visualization type above, or load a spec first.</div>';
        });
        
        // Keyboard shortcuts
        document.getElementById('queryInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                runQuery();
            }
        });
        
        document.getElementById('propertyInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkProperty();
            }
        });
        
        document.getElementById('chatInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                sendChat();
            }
        });
        
        function setStatus(message, type = 'info') {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (type === 'error') {
                indicator.classList.add('error');
            } else if (type === 'success') {
                indicator.classList.add('success');
            }
        }
        
        function switchProvider() {
            const provider = document.getElementById('providerSelect').value;
            fetch('/api/provider', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ provider })
            }).then(() => {
                setStatus(`Switched to ${provider}`, 'success');
            }).catch(err => {
                setStatus(`Failed to switch: ${err.message}`, 'error');
            });
        }
        
        function generateActorStateMachinesMermaid(actors) {
            if (!actors || actors.length === 0) {
                return null;
            }
            
            let code = '';
            actors.forEach((actor, idx) => {
                if (idx > 0) code += '\n\n';
                code += `stateDiagram-v2\n`;
                code += `    direction LR\n`;
                code += `    %% ${actor.actor}\n`;
                
                if (actor.initial) {
                    code += `    [*] --> ${actor.initial}\n`;
                }
                
                actor.transitions.forEach(t => {
                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                });
            });
            
            return code;
        }
        
        // Add this function and call it when spec loads:

        async function loadDocs() {
            try {
                const resp = await fetch('/api/docs');
                const data = await resp.json();
                const actorsResp = await fetch('/api/actors');
                const actorsData = await actorsResp.json();
                
                const container = document.getElementById('docsContent');
                const docs = (data.success && data.docs) ? data.docs : [];
                const actors = (actorsData.success && actorsData.actors) ? actorsData.actors : [];
                const docsByTopic = new Map(docs.map(doc => [doc.topic, doc.content]));
                
                const renderActorCards = (targetId) => {
                    const target = document.getElementById(targetId);
                    if (!target) return;
                    
                    if (actors.length === 0) {
                        target.innerHTML = '<div style="color: var(--text-secondary);">No actors defined. Add actor/1 facts.</div>';
                        return;
                    }
                    
                    let html = '<div style="margin-bottom: 12px;">';
                    html += '<div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Actors</div>';
                    
                    actors.forEach(actor => {
                        const roleKey = `role_${actor}`;
                        const actorKey = `actor_${actor}`;
                        const description = docsByTopic.get(roleKey) || docsByTopic.get(actorKey) || '';
                        const fallback = `Add doc(role_${actor}, '...') to describe intent.`;
                        html += `<div style="margin-bottom: 10px; padding: 8px 10px; background: var(--bg-secondary); border-radius: 4px; border: 1px solid var(--border-color);">`;
                        html += `<div style="color: var(--accent-blue); font-weight: 600; font-size: 0.9rem;">${actor}</div>`;
                        html += `<div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 4px;">${description || fallback}</div>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    target.innerHTML = html;
                };
                
                renderActorCards('actorSummary');
                
                if (docs.length > 0) {
                    // Group docs by category based on topic prefix
                    const sections = {
                        'Overview': [],
                        'Roles': [],
                        'Phases': [],
                        'Safety': [],
                        'Visualizations': [],
                        'Other': []
                    };
                    
                    docs.forEach(doc => {
                        const topic = doc.topic || '';
                        if (topic === 'title' || topic === 'version' || topic === 'author' || topic === 'overview' || topic === 'description') {
                            sections['Overview'].push(doc);
                        } else if (topic.startsWith('role_')) {
                            sections['Roles'].push(doc);
                        } else if (topic.startsWith('phase')) {
                            sections['Phases'].push(doc);
                        } else if (topic.startsWith('safety_')) {
                            sections['Safety'].push(doc);
                        } else if (topic.startsWith('viz_')) {
                            sections['Visualizations'].push(doc);
                        } else {
                            sections['Other'].push(doc);
                        }
                    });
                    
                    let html = '';
                    
                    // Render Overview section specially
                    if (sections['Overview'].length > 0) {
                        const titleDoc = sections['Overview'].find(d => d.topic === 'title');
                        const versionDoc = sections['Overview'].find(d => d.topic === 'version');
                        const overviewDoc = sections['Overview'].find(d => d.topic === 'overview');
                        const descDoc = sections['Overview'].find(d => d.topic === 'description');
                        
                        html += `<div style="margin-bottom: 24px;">`;
                        if (titleDoc) {
                            html += `<h2 style="color: var(--accent-blue); margin: 0;">${titleDoc.content}</h2>`;
                        }
                        if (versionDoc) {
                            html += `<div style="color: var(--text-secondary); font-size: 0.85rem;">Version ${versionDoc.content}</div>`;
                        }
                        if (overviewDoc) {
                            html += `<p style="margin-top: 12px; color: var(--text-primary);">${overviewDoc.content}</p>`;
                        }
                        if (descDoc) {
                            html += `<p style="margin-top: 8px; color: var(--text-secondary);">${descDoc.content}</p>`;
                        }
                        html += `</div>`;
                    }
                    
                    if (actors.length > 0) {
                        html += '<div style="margin-bottom: 20px;">';
                        html += '<h3 style="color: var(--accent-purple); margin: 0 0 8px 0; font-size: 1rem;">Actors</h3>';
                        actors.forEach(actor => {
                            const roleKey = `role_${actor}`;
                            const actorKey = `actor_${actor}`;
                            const description = docsByTopic.get(roleKey) || docsByTopic.get(actorKey) || '';
                            const fallback = `Add doc(role_${actor}, '...') to describe intent.`;
                            html += `<div style="margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 4px;">`;
                            html += `<div style="font-weight: 500; color: var(--accent-blue); font-size: 0.9rem;">${actor}</div>`;
                            html += `<div style="color: var(--text-primary); font-size: 0.85rem; margin-top: 4px;">${description || fallback}</div>`;
                            html += `</div>`;
                        });
                        html += '</div>';
                    }
                    
                    // Render other sections
                    const sectionOrder = ['Roles', 'Phases', 'Safety', 'Visualizations', 'Other'];
                    for (const sectionName of sectionOrder) {
                        const docs = sections[sectionName];
                        if (docs.length === 0) continue;
                        
                        html += `<div style="margin-bottom: 20px;">`;
                        html += `<h3 style="color: var(--accent-purple); margin: 0 0 8px 0; font-size: 1rem;">${sectionName}</h3>`;
                        
                        docs.forEach(doc => {
                            // Clean up topic name for display
                            let displayTopic = doc.topic
                                .replace(/^(role_|phase|safety_|viz_)/, '')
                                .replace(/_/g, ' ')
                                .replace(/\b\w/g, c => c.toUpperCase());
                            
                            html += `<div style="margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 4px;">`;
                            html += `<div style="font-weight: 500; color: var(--accent-blue); font-size: 0.9rem;">${displayTopic}</div>`;
                            html += `<div style="color: var(--text-primary); font-size: 0.85rem; margin-top: 4px;">${doc.content}</div>`;
                            html += `</div>`;
                        });
                        
                        html += `</div>`;
                    }
                    
                    container.innerHTML = html;
                } else {
                    container.innerHTML = '<div style="color: var(--text-secondary);">No documentation in spec. Add doc(topic, content) facts.</div>';
                }
            } catch (err) {
                console.error('Error loading docs:', err);
            }
        }
        
        async function loadPromptPreview() {
            try {
                const [promptResp, specResp] = await Promise.all([
                    fetch('/api/system-prompt'),
                    fetch('/api/spec')
                ]);
                const promptData = await promptResp.json();
                const specData = await specResp.json();
                
                const systemPrompt = document.getElementById('systemPromptText');
                const userPrompt = document.getElementById('userPromptText');
                const editorValue = document.getElementById('specEditor')?.value || '';
                const chatValue = document.getElementById('chatInput')?.value.trim() || '<your message>';
                
                systemPrompt.textContent = promptData.success ? promptData.prompt : 'No system prompt available.';
                
                let preview = '';
                const currentSpec = specData && specData.source ? specData.source : '';
                if (currentSpec) {
                    preview += 'Current specification:\n```prolog\n' + currentSpec + '\n```\n\n';
                }
                if (editorValue) {
                    preview += 'Context:\n' + editorValue + '\n\n';
                }
                preview += 'User request:\n' + chatValue;
                
                userPrompt.textContent = preview;
            } catch (err) {
                console.error('Error loading prompt preview:', err);
            }
        }
        
        // Update applySpec to also load docs
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                    loadDocs();  // Add this line
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        // Also load docs on page load
        // Add after loadProperties() call:
        loadProperties();
        loadDocs();
        loadPromptPreview();
    </script>
</body>
</html>
