<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turducken - Formal Methods in Prolog</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            font-size: 1.8rem;
            color: var(--accent-blue);
        }
        
        h1 span {
            color: var(--text-secondary);
            font-weight: normal;
            font-size: 1rem;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
        }
        
        .status-indicator.error {
            background: var(--accent-red);
        }
        
        .status-indicator.success {
            background: var(--accent-green);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 120px);
        }
        
        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .panel-body {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .tabs {
            display: flex;
            gap: 4px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .tab {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: var(--accent-blue);
            color: white;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .editor {
            flex: 1;
            min-height: 200px;
            resize: none;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }
        
        .btn-primary:hover {
            background: #4393e6;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--border-color);
        }
        
        .btn-success {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .output {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.85rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .output.success {
            border-color: var(--accent-green);
        }
        
        .output.error {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 12px;
            padding-right: 8px;
        }
        
        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .message.user {
            background: var(--bg-tertiary);
            margin-left: 40px;
        }
        
        .message.assistant {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            margin-right: 40px;
        }
        
        .message-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .chat-input-area {
            flex-shrink: 0;
        }
        
        .chat-input-area textarea {
            min-height: 80px;
        }
        
        .mermaid-output {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            overflow: auto;
            flex: 1;
            min-height: 500px;
        }
        
        .mermaid-output .mermaid {
            min-width: 800px;
        }
        
        .mermaid-output svg {
            min-width: 700px;
            min-height: 400px;
        }
        
        .property-check {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .property-check input {
            flex: 1;
        }
        
        .check-result {
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .check-result.satisfied {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .check-result.unsatisfied {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .tab-content {
            display: none;
            flex: 1;
            flex-direction: column;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        pre code {
            display: block;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            overflow-x: auto;
        }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .help-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 8px;
        }
        
        .examples {
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .example-btn {
            font-size: 0.8rem;
            padding: 4px 8px;
            margin-right: 4px;
            margin-bottom: 4px;
        }
        
        .viz-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Turducken <span>Formal Methods in Prolog</span></h1>
            <div class="status">
                <select id="providerSelect" class="btn btn-secondary" style="padding: 4px 8px; font-size: 0.85rem;" onchange="switchProvider()">
                    <option value="openai">ChatGPT</option>
                    <option value="anthropic">Claude</option>
                </select>
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Ready</span>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Spec & Visualization -->
            <div class="panel">
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('viz')">üìä Visualize</button>
                    <button class="tab" onclick="switchTab('spec')">üìù Prolog</button>
                    <button class="tab" onclick="switchTab('query')">üîç Query</button>
                    <button class="tab" onclick="switchTab('check')">‚úì Check</button>
                </div>
                
                <!-- Visualize Tab -->
                <div id="tab-viz" class="tab-content active">
                    <div class="panel-body">
                        <div class="viz-buttons">
                            <button class="btn btn-secondary" onclick="visualize('statemachine')">State Machine</button>
                            <button class="btn btn-secondary" onclick="visualize('sequence')">Sequence</button>
                            <button class="btn btn-secondary" onclick="visualize('pie')">Pie Chart</button>
                            <button class="btn btn-secondary" onclick="visualize('line')">Line Chart</button>
                        </div>
                        <div id="vizOutput" class="mermaid-output">
                            <div style="color: var(--text-secondary); text-align: center;">
                                Select a visualization type above
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Prolog Spec Tab -->
                <div id="tab-spec" class="tab-content">
                    <div class="panel-body">
                        <textarea id="specEditor" class="editor" placeholder="% Enter your Prolog specification here...

% Example state machine:
state(idle, [waiting]).
state(busy, [processing]).
initial(idle).
transition(idle, start, busy).
transition(busy, done, idle).
"></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="applySpec()">Apply Spec</button>
                            <button class="btn btn-secondary" onclick="resetEngine()">Reset</button>
                        </div>
                        <div class="examples">
                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Examples: </span>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('mutex')">Mutex</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('channel')">Channel</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('sequence')">Sequence</button>
                        </div>
                    </div>
                </div>
                
                <!-- Query Tab -->
                <div id="tab-query" class="tab-content">
                    <div class="panel-body">
                        <input type="text" id="queryInput" placeholder="Enter Prolog query (e.g., transition(X, Y, Z).)">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="runQuery()">Run Query</button>
                        </div>
                        <div class="help-text">
                            Try: <code>transition(X, _, Y).</code> or <code>initial(X).</code>
                        </div>
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-secondary);">Result:</h4>
                        <div id="queryOutput" class="output"></div>
                    </div>
                </div>
                
                <!-- Check Tab -->
                <div id="tab-check" class="tab-content">
                    <div class="panel-body">
                        <h4 style="margin: 0 0 12px 0; color: var(--text-primary);">Defined Properties</h4>
                        <div id="propertyList" style="margin-bottom: 16px;">
                            <div style="color: var(--text-secondary);">Load a spec to see defined properties</div>
                        </div>
                        
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary);">Custom Check</h4>
                        <div class="property-check">
                            <input type="text" id="propertyInput" placeholder="CTL formula (e.g., ef(atom(done)))">
                            <button class="btn btn-primary" onclick="checkProperty()">Check</button>
                        </div>
                        <div class="help-text">
                            CTL operators: <code>ef</code>, <code>af</code>, <code>eg</code>, <code>ag</code>, <code>ex</code>, <code>ax</code>, <code>eu</code>, <code>au</code><br>
                            Combinators: <code>atom(p)</code>, <code>not(œÜ)</code>, <code>and(œÜ,œà)</code>, <code>or(œÜ,œà)</code>
                        </div>
                        <div id="checkResult"></div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Chat Only -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">üí¨ Chat</span>
                    <button class="btn btn-secondary" onclick="clearChat()" style="padding: 4px 12px;">Clear</button>
                </div>
                <div class="panel-body chat-container">
                    <div id="chatMessages" class="chat-messages">
                        <div class="message assistant">
                            <div class="message-label">Turducken</div>
                            Describe the system you want to model, and I'll generate a Prolog specification. 
                            You can ask me to model state machines, protocols, processes, or any system with temporal properties.
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <textarea id="chatInput" rows="3" placeholder="Describe your system or ask a question..."></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="sendChat()">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        // Initialize Mermaid with dark theme
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                darkMode: true,
                background: '#0d1117',
                primaryColor: '#58a6ff',
                primaryTextColor: '#e6edf3',
                primaryBorderColor: '#30363d',
                lineColor: '#8b949e',
                secondaryColor: '#21262d',
                tertiaryColor: '#161b22'
            }
        });
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }
        
        // API calls
        // Regular apply - no auto-fix
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        async function resetEngine() {
            try {
                await fetch('/api/reset', { method: 'POST' });
                setStatus('success', 'Reset complete');
            } catch (err) {
                setStatus('error', 'Reset failed');
            }
        }
        
        async function runQuery() {
            const query = document.getElementById('queryInput').value;
            const output = document.getElementById('queryOutput');
            
            if (!query) {
                output.textContent = 'Enter a query';
                return;
            }
            
            try {
                const resp = await fetch('/api/query', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await resp.json();
                
                output.className = 'output ' + (data.success ? 'success' : 'error');
                output.textContent = data.success ? data.result : 'Error: ' + data.error;
            } catch (err) {
                output.className = 'output error';
                output.textContent = 'Failed: ' + err.message;
            }
        }
        
        async function checkProperty() {
            const property = document.getElementById('propertyInput').value;
            const resultDiv = document.getElementById('checkResult');
            
            if (!property) {
                resultDiv.innerHTML = '';
                return;
            }
            
            try {
                const resp = await fetch('/api/check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ property })
                });
                const data = await resp.json();
                
                if (data.success) {
                    resultDiv.innerHTML = `<div class="check-result ${data.satisfied ? 'satisfied' : 'unsatisfied'}">
                        ${data.satisfied ? '‚úì Property SATISFIED' : '‚úó Property NOT satisfied'}
                    </div>`;
                } else {
                    resultDiv.innerHTML = `<div class="check-result unsatisfied">Error: ${data.error}</div>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<div class="check-result unsatisfied">Failed: ${err.message}</div>`;
            }
        }
        
        function setProperty(prop) {
            document.getElementById('propertyInput').value = prop;
        }
        
        async function sendChat() {
            const input = document.getElementById('chatInput');
            const messages = document.getElementById('chatMessages');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            messages.innerHTML += `<div class="message user">
                <div class="message-label">You</div>
                ${escapeHtml(message)}
            </div>`;
            
            input.value = '';
            messages.scrollTop = messages.scrollHeight;
            
            // Show loading
            const loadingId = 'loading-' + Date.now();
            messages.innerHTML += `<div id="${loadingId}" class="message assistant">
                <div class="message-label">Turducken</div>
                <div class="loading"></div> Thinking...
            </div>`;
            messages.scrollTop = messages.scrollHeight;
            
            try {
                const resp = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message,
                        context: document.getElementById('specEditor').value
                    })
                });
                const data = await resp.json();
                
                // Remove loading message
                document.getElementById(loadingId)?.remove();
                
                if (data.success) {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Turducken</div>
                        ${formatResponse(data.response)}
                    </div>`;
                    
                    // If there's Prolog code, auto-populate the editor
                    if (data.prolog) {
                        document.getElementById('specEditor').value = data.prolog;
                        
                        // Add apply button
                        messages.innerHTML += `<div class="message assistant" style="padding: 8px 12px;">
                            <button class="btn btn-success" onclick="applyAndVisualize()">
                                ‚úì Apply Spec & Visualize
                            </button>
                            <span style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 8px;">
                                Prolog populated in editor
                            </span>
                        </div>`;
                    }
                } else {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Error</div>
                        ${data.error}
                    </div>`;
                }
            } catch (err) {
                document.getElementById(loadingId)?.remove();
                messages.innerHTML += `<div class="message assistant">
                    <div class="message-label">Error</div>
                    ${err.message}
                </div>`;
            }
            
            messages.scrollTop = messages.scrollHeight;
        }
        
        async function applyAndVisualize() {
            await applySpec();
            switchTab('viz');
            visualize('statemachine');
        }
        
        function clearChat() {
            document.getElementById('chatMessages').innerHTML = `<div class="message assistant">
                <div class="message-label">Turducken</div>
                Describe the system you want to model, and I'll generate a Prolog specification.
            </div>`;
        }
        
        async function visualize(type) {
            const output = document.getElementById('vizOutput');
            output.innerHTML = '<div class="loading"></div>';
            
            try {
                const resp = await fetch(`/api/visualize?type=${type}`);
                const data = await resp.json();
                
                let mermaidCode = '';
                
                switch (type) {
                    case 'statemachine':
                        mermaidCode = generateStateMachineMermaid(data.stateMachine);
                        break;
                    case 'sequence':
                        mermaidCode = generateSequenceMermaid(data.sequence);
                        break;
                    case 'pie':
                        // Fetch real metrics
                        const metricsResp = await fetch('/api/metrics');
                        const metrics = await metricsResp.json();
                        if (metrics.counters) {
                            const slices = Object.entries(metrics.counters).map(([label, value]) => ({
                                label,
                                value
                            }));
                            mermaidCode = generatePieMermaid({ slices });
                        }
                        break;
                    case 'line':
                        // Fetch real metrics time series
                        const tsResp = await fetch('/api/metrics');
                        const tsData = await tsResp.json();
                        if (tsData.timeSeries && tsData.timeSeries.length > 0) {
                            // Group by counter name
                            const seriesMap = new Map();
                            tsData.timeSeries.forEach((pt, idx) => {
                                if (!seriesMap.has(pt.counter)) {
                                    seriesMap.set(pt.counter, []);
                                }
                                seriesMap.get(pt.counter).push({ x: idx, y: pt.value });
                            });
                            
                            const series = Array.from(seriesMap.entries()).map(([name, points]) => ({
                                name,
                                points
                            }));
                            mermaidCode = generateLineMermaid({ series });
                        }
                        break;
                }
                
                if (mermaidCode) {
                                    output.innerHTML = `<pre class="mermaid">${mermaidCode}</pre>`;
                                    try {
                                        await mermaid.run();
                                    } catch (mermaidErr) {
                                        console.error('Mermaid error:', mermaidErr, 'Code:', mermaidCode);
                                        output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem; white-space: pre-wrap;">${mermaidCode}</pre>`;
                                    }
                                } else {
                                    output.innerHTML = '<div style="color: var(--text-secondary);">No data to visualize. Load a specification first.</div>';
                                }
                            } catch (err) {
                                output.innerHTML = `<div style="color: var(--accent-red);">Error: ${err.message}</div>`;
                            }
                        }
                        
                        function generateStateMachineMermaid(data) {
                            if (!data || !data.transitions || data.transitions.length === 0) {
                                return null;
                            }
                            
                            let code = 'stateDiagram-v2\n';
                            
                            if (data.initial && data.initial.length > 0) {
                                data.initial.forEach(s => {
                                    code += `    [*] --> ${s}\n`;
                                });
                            }
                            
                            if (data.transitions) {
                                data.transitions.forEach(t => {
                                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                                });
                            }
                            
                            if (data.accepting && data.accepting.length > 0) {
                                data.accepting.forEach(s => {
                                    code += `    ${s} --> [*]\n`;
                                });
                            }
                            
                            return code;
                        }
                        
                        function generateSequenceMermaid(data) {
                            if (!data || !data.messages || data.messages.length === 0) {
                                return null;
                            }
                            
                            let code = 'sequenceDiagram\n';
                            
                            if (data.lifelines) {
                                data.lifelines.forEach(l => {
                                    code += `    participant ${l}\n`;
                                });
                            }
                            
                            if (data.messages) {
                                data.messages.forEach(m => {
                                    code += `    ${m.from}->>${m.to}: ${m.label}\n`;
                                });
                            }
                            
                            return code;
                        }
                        
                        function generatePieMermaid(data) {
                            if (!data || !data.slices || data.slices.length === 0) {
                                return null;
                            }
                            
                            let code = 'pie title Request Distribution\n';
                            data.slices.forEach(s => {
                                code += `    "${s.label}" : ${s.value}\n`;
                            });
                            return code;
                        }
                        
                        function generateLineMermaid(data) {
                            if (!data || !data.series || data.series.length === 0) {
                                return null;
                            }
                            
                            const allXValues = new Set();
                            data.series.forEach(series => {
                                if (series.points) {
                                    series.points.forEach(p => allXValues.add(p.x));
                                }
                            });
                            
                            if (allXValues.size === 0) {
                                return null;
                            }
                            
                            const sortedX = [...allXValues].sort((a, b) => a - b);
                            const xValues = sortedX.map(x => `"${x}"`).join(', ');
                            
                            let maxY = 0;
                            data.series.forEach(series => {
                                if (series.points) {
                                    series.points.forEach(p => {
                                        if (p.y > maxY) maxY = p.y;
                                    });
                                }
                            });
                            maxY += 5;
                            
                            let code = `xychart-beta
                    title "Metrics Over Time"
                    x-axis [${xValues}]
                    y-axis "Value" 0 --> ${maxY}`;
                            
                            data.series.forEach(series => {
                                if (series.points && series.points.length > 0) {
                                    const pointMap = new Map();
                                    series.points.forEach(p => pointMap.set(p.x, p.y));
                                    const yValues = sortedX.map(x => pointMap.has(x) ? pointMap.get(x) : 0).join(', ');
                                    code += `\n    line [${yValues}]`;
                                }
                            });
                            
                            return code;
                        }
                        
                        // Example specifications
                        const examples = {
                            mutex: `% Mutual Exclusion Protocol
                state(free, [available]).
                state(locked, [busy]).
                
                initial(free).
                
                transition(free, acquire, locked).
                transition(locked, release, free).
                
                prop(free, available).
                prop(locked, busy).
                
                property(no_deadlock, 'Can always release', 'ag(ef(atom(available)))').`,
                
                            channel: `% Buffered Channel (CSP style)
                state(empty, [can_send]).
                state(has_one, [can_send, can_recv]).
                state(full, [can_recv]).
                
                initial(empty).
                
                transition(empty, send, has_one).
                transition(has_one, send, full).
                transition(full, recv, has_one).
                transition(has_one, recv, empty).
                
                prop(empty, can_send).
                prop(has_one, can_send).
                prop(has_one, can_recv).
                prop(full, can_recv).
                
                property(liveness, 'Can always send again', 'ag(ef(atom(can_send)))').`,
                
                            sequence: `% Request-Response Protocol
                lifeline(client).
                lifeline(server).
                lifeline(database).
                
                message(1, client, server, request).
                message(2, server, database, query).
                message(3, database, server, result).
                message(4, server, client, response).
                
                state(idle, [ready]).
                state(requesting, [busy]).
                state(querying, [busy]).
                state(responding, [busy]).
                
                initial(idle).
                accepting(idle).
                
                transition(idle, request, requesting).
                transition(requesting, query, querying).
                transition(querying, result, responding).
                transition(responding, response, idle).
                
                prop(idle, ready).
                prop(requesting, busy).
                prop(querying, busy).
                prop(responding, busy).
                
                property(completes, 'Requests complete', 'ag(or(not(atom(busy)), af(atom(ready))))').`
                        };
                        
                        function loadExample(name) {
                            document.getElementById('specEditor').value = examples[name];
                            switchTab('spec');
                        }
                        
                        const MAX_AUTO_FIX_RETRIES = 3;
                        
                        async function loadProperties() {
                            try {
                                const resp = await fetch('/api/properties');
                                const data = await resp.json();
                                
                                const listDiv = document.getElementById('propertyList');
                                if (data.success && data.properties && data.properties.length > 0) {
                                    listDiv.innerHTML = data.properties.map(p => {
                                        let statusIcon = '';
                                        let statusColor = '';
                                        if (p.error) {
                                            statusIcon = '‚ö†Ô∏è';
                                            statusColor = 'var(--accent-yellow)';
                                        } else if (p.satisfied === true) {
                                            statusIcon = '‚úì';
                                            statusColor = 'var(--accent-green)';
                                        } else if (p.satisfied === false) {
                                            statusIcon = '‚úó';
                                            statusColor = 'var(--accent-red)';
                                        }
                                        
                                        return `
                                        <div style="margin-bottom: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <div style="flex: 1;">
                                                    <div style="display: flex; align-items: center; gap: 8px;">
                                                        <span style="color: ${statusColor}; font-size: 1.2rem;">${statusIcon}</span>
                                                        <strong style="color: var(--accent-blue);">${p.name}</strong>
                                                    </div>
                                                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-left: 28px;">${p.description}</div>
                                                    ${p.error ? `<div style="font-size: 0.8rem; color: var(--accent-red); margin-left: 28px;">Error: ${p.error}</div>` : ''}
                                                </div>
                                                <button class="btn btn-secondary" onclick="checkNamedProperty('${p.name}', '${p.formula.replace(/'/g, "\\'")}')">Recheck</button>
                                            </div>
                                        </div>
                                    `}).join('');
                                } else {
                                    listDiv.innerHTML = '<div style="color: var(--text-secondary);">No named properties defined in spec</div>';
                                }
                            } catch (err) {
                                console.error('Error loading properties:', err);
                            }
                        }
                
                        async function checkNamedProperty(name, formula) {
                            document.getElementById('propertyInput').value = formula;
                            await checkProperty();
                        }
                        
                        function escapeHtml(text) {
                            const div = document.createElement('div');
                            div.textContent = text;
                            return div.innerHTML;
                        }
                        
                        function formatResponse(text) {
                            // Simple markdown-like formatting
                            return escapeHtml(text)
                                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                                .replace(/`([^`]+)`/g, '<code>$1</code>')
                                .replace(/\n/g, '<br>');
                        }
                        
                        // Initialize on page load
                        loadProperties();
                        
                        window.addEventListener('load', () => {
                            document.getElementById('vizOutput').innerHTML = '<div style="color: var(--text-secondary);">Select a visualization type above, or load a spec first.</div>';
                        });
                        
                        // Keyboard shortcuts
                        document.getElementById('queryInput').addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                runQuery();
                            }
                        });
                        
                        document.getElementById('propertyInput').addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                checkProperty();
                            }
                        });
                        
                        document.getElementById('chatInput').addEventListener('keydown', (e) => {
                            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                                e.preventDefault();
                                sendChat();
                            }
                        });
                        
                        function setStatus(message, type = 'info') {
                            const indicator = document.getElementById('statusIndicator');
                            const text = document.getElementById('statusText');
                            
                            text.textContent = message;
                            indicator.className = 'status-indicator';
                            
                            if (type === 'error') {
                                indicator.classList.add('error');
                            } else if (type === 'success') {
                                indicator.classList.add('success');
                            }
                        }
                        
                        function switchProvider() {
                            const provider = document.getElementById('providerSelect').value;
                            fetch('/api/provider', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ provider })
                            }).then(() => {
                                setStatus(`Switched to ${provider}`, 'success');
                            }).catch(err => {
                                setStatus(`Failed to switch: ${err.message}`, 'error');
                            });
                        }
                        
                        function generateActorStateMachinesMermaid(actors) {
                            if (!actors || actors.length === 0) {
                                return null;
                            }
                            
                            let code = '';
                            actors.forEach((actor, idx) => {
                                if (idx > 0) code += '\n\n';
                                code += `stateDiagram-v2\n`;
                                code += `    direction LR\n`;
                                code += `    %% ${actor.actor}\n`;
                                
                                if (actor.initial) {
                                    code += `    [*] --> ${actor.initial}\n`;
                                }
                                
                                actor.transitions.forEach(t => {
                                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                                });
                            });
                            
                            return code;
                        }
                    </script>
                </body>
                </html>
