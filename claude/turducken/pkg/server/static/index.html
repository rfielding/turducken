<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turducken - Formal Methods in Prolog</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            font-size: 1.8rem;
            color: var(--accent-blue);
        }
        
        h1 span {
            color: var(--text-secondary);
            font-weight: normal;
            font-size: 1rem;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
        }
        
        .status-indicator.error {
            background: var(--accent-red);
        }
        
        .status-indicator.success {
            background: var(--accent-green);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 120px);
        }
        
        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .panel-body {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .tabs {
            display: flex;
            gap: 4px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .tab {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: var(--accent-blue);
            color: white;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .editor {
            flex: 1;
            min-height: 200px;
            resize: none;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }
        
        .btn-primary:hover {
            background: #4393e6;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--border-color);
        }
        
        .btn-success {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .output {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.85rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .output.success {
            border-color: var(--accent-green);
        }
        
        .output.error {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 12px;
            padding-right: 8px;
        }
        
        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .message.user {
            background: var(--bg-tertiary);
            margin-left: 40px;
        }
        
        .message.assistant {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            margin-right: 40px;
        }
        
        .message-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .chat-input-area {
            flex-shrink: 0;
        }
        
        .chat-input-area textarea {
            min-height: 80px;
        }
        
        .mermaid-output {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        
        .mermaid-output .mermaid {
            min-width: auto;
        }
        
        .mermaid-output svg {
            min-width: auto;
            min-height: auto;
            max-width: 100%;
        }
        
        .property-check {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .property-check input {
            flex: 1;
        }
        
        .check-result {
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .check-result.satisfied {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .check-result.unsatisfied {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .tab-content {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        pre code {
            display: block;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            overflow-x: auto;
        }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .help-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 8px;
        }
        
        .examples {
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .example-btn {
            font-size: 0.8rem;
            padding: 4px 8px;
            margin-right: 4px;
            margin-bottom: 4px;
        }
        
        .viz-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Turducken <span>Formal Methods in Prolog</span></h1>
            <div class="status">
                <select id="providerSelect" class="btn btn-secondary" style="padding: 4px 8px; font-size: 0.85rem;" onchange="switchProvider()">
                    <option value="openai">ChatGPT</option>
                    <option value="anthropic">Claude</option>
                </select>
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Ready</span>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Spec & Visualization -->
            <div class="panel">
                <!-- Add new tab button in the tabs div -->
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('viz')">üìä Visualize</button>
                    <button class="tab" onclick="switchTab('docs')">üìñ Docs</button>
                    <button class="tab" onclick="switchTab('spec')">üìù Prolog</button>
                    <button class="tab" onclick="switchTab('query')">üîç Query</button>
                    <button class="tab" onclick="switchTab('check')">‚úì Check</button>
                </div>
                
                <!-- Visualize Tab -->
                <div id="tab-viz" class="tab-content active">
                    <div class="panel-body">
                        <div class="viz-buttons">
                            <button class="btn btn-secondary" onclick="visualize('statemachine')">State Machine</button>
                            <button class="btn btn-secondary" onclick="visualize('sequence')">Sequence</button>
                            <button class="btn btn-secondary" onclick="visualize('pie')">Pie Chart</button>
                            <button class="btn btn-secondary" onclick="visualize('line')">Line Chart</button>
                        </div>
                        <div id="actorSummary" style="margin-bottom: 12px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; border: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary);">Load a spec to see actor descriptions.</div>
                        </div>
                        <div id="vizOutput" class="mermaid-output">
                            <div style="color: var(--text-secondary); text-align: center;">
                                Select a visualization type above
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Prolog Spec Tab -->
                <div id="tab-spec" class="tab-content">
                    <div class="panel-body">
                        <textarea id="specEditor" class="editor" placeholder="% Enter your Prolog specification here...

% Example state machine:
state(idle, [waiting]).
state(busy, [processing]).
initial(idle).
transition(idle, start, busy).
transition(busy, done, idle).
"></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="applySpec()">Apply Spec</button>
                            <button class="btn btn-secondary" onclick="resetEngine()">Reset</button>
                        </div>
                        <div class="examples">
                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Examples: </span>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('mutex')">Mutex</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('channel')">Channel</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('sequence')">Sequence</button>
                            <button class="btn btn-secondary example-btn" onclick="loadExample('bread_company')">Bread Company</button>
                        </div>
                    </div>
                </div>
                
                <!-- Query Tab -->
                <div id="tab-query" class="tab-content">
                    <div class="panel-body">
                        <input type="text" id="queryInput" placeholder="Enter Prolog query (e.g., transition(X, Y, Z).)">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="runQuery()">Run Query</button>
                        </div>
                        <div class="help-text">
                            Try: <code>transition(X, _, Y).</code> or <code>initial(X).</code>
                        </div>
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-secondary);">Result:</h4>
                        <div id="queryOutput" class="output"></div>
                    </div>
                </div>
                
                <!-- Check Tab -->
                <div id="tab-check" class="tab-content">
                    <div class="panel-body">
                        <h4 style="margin: 0 0 12px 0; color: var(--text-primary);">Properties</h4>
                        <div id="propertyList" style="margin-bottom: 16px;">
                            <div style="color: var(--text-secondary);">Load a spec to see defined properties</div>
                        </div>
                        
                        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary);">Custom Check</h4>
                        <div class="property-check">
                            <input type="text" id="propertyInput" placeholder="CTL formula (e.g., ef(atom(done)))">
                            <button class="btn btn-primary" onclick="checkProperty()">Check</button>
                        </div>
                        <div class="help-text">
                            CTL operators: <code>ef</code>, <code>af</code>, <code>eg</code>, <code>ag</code>, <code>ex</code>, <code>ax</code>, <code>eu</code>, <code>au</code><br>
                            Combinators: <code>atom(p)</code>, <code>not(œÜ)</code>, <code>and(œÜ,œà)</code>, <code>or(œÜ,œà)</code>
                        </div>
                        <div id="checkResult"></div>
                    </div>
                </div>
                
                <!-- Docs Tab -->
                <div id="tab-docs" class="tab-content">
                    <div class="panel-body" style="overflow-y: auto; min-height: 0; flex: 1;">
                        <div id="docsContent" style="overflow-y: auto; height: 100%;">
                            <div style="color: var(--text-secondary);">Load a spec to see documentation</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Chat Only -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">üí¨ Chat</span>
                    <button class="btn btn-secondary" onclick="clearChat()" style="padding: 4px 12px;">Clear</button>
                </div>
                <div class="panel-body chat-container">
                    <div id="chatMessages" class="chat-messages">
                        <div class="message assistant">
                            <div class="message-label">Turducken</div>
                            Describe the system you want to model, and I'll generate a Prolog specification. 
                            You can ask me to model state machines, protocols, processes, or any system with temporal properties.
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <textarea id="chatInput" rows="3" placeholder="Describe your system or ask a question..."></textarea>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="sendChat()">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        // Initialize Mermaid with dark theme
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                darkMode: true,
                background: '#0d1117',
                primaryColor: '#58a6ff',
                primaryTextColor: '#e6edf3',
                primaryBorderColor: '#30363d',
                lineColor: '#8b949e',
                secondaryColor: '#21262d',
                tertiaryColor: '#161b22'
            }
        });
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }
        
        // API calls
        // Regular apply - no auto-fix
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                    loadDocs();  // Add this line
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        async function resetEngine() {
            try {
                await fetch('/api/reset', { method: 'POST' });
                setStatus('success', 'Reset complete');
            } catch (err) {
                setStatus('error', 'Reset failed');
            }
        }
        
        async function runQuery() {
            const query = document.getElementById('queryInput').value;
            const output = document.getElementById('queryOutput');
            
            if (!query) {
                output.textContent = 'Enter a query';
                return;
            }
            
            try {
                const resp = await fetch('/api/query', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                const data = await resp.json();
                
                output.className = 'output ' + (data.success ? 'success' : 'error');
                output.textContent = data.success ? data.result : 'Error: ' + data.error;
            } catch (err) {
                output.className = 'output error';
                output.textContent = 'Failed: ' + err.message;
            }
        }
        
        async function checkProperty() {
            const property = document.getElementById('propertyInput').value;
            const resultDiv = document.getElementById('checkResult');
            
            if (!property) {
                resultDiv.innerHTML = '';
                return;
            }
            
            try {
                const resp = await fetch('/api/check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ property })
                });
                const data = await resp.json();
                
                if (data.success) {
                    resultDiv.innerHTML = `<div class="check-result ${data.satisfied ? 'satisfied' : 'unsatisfied'}">
                        ${data.satisfied ? '‚úì Property SATISFIED' : '‚úó Property NOT satisfied'}
                    </div>`;
                } else {
                    resultDiv.innerHTML = `<div class="check-result unsatisfied">Error: ${data.error}</div>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<div class="check-result unsatisfied">Failed: ${err.message}</div>`;
            }
        }
        
        function setProperty(prop) {
            document.getElementById('propertyInput').value = prop;
        }
        
        async function sendChat() {
            const input = document.getElementById('chatInput');
            const messages = document.getElementById('chatMessages');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            messages.innerHTML += `<div class="message user">
                <div class="message-label">You</div>
                ${escapeHtml(message)}
            </div>`;
            
            input.value = '';
            messages.scrollTop = messages.scrollHeight;
            
            // Show loading
            const loadingId = 'loading-' + Date.now();
            messages.innerHTML += `<div id="${loadingId}" class="message assistant">
                <div class="message-label">Turducken</div>
                <div class="loading"></div> Thinking...
            </div>`;
            messages.scrollTop = messages.scrollHeight;
            
            try {
                const resp = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message,
                        context: document.getElementById('specEditor').value
                    })
                });
                const data = await resp.json();
                
                // Remove loading message
                document.getElementById(loadingId)?.remove();
                
                if (data.success) {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Turducken</div>
                        ${formatResponse(data.response)}
                    </div>`;
                    
                    // If there's Prolog code, auto-populate the editor
                    if (data.prolog) {
                        document.getElementById('specEditor').value = data.prolog;
                        
                        // Add apply button
                        messages.innerHTML += `<div class="message assistant" style="padding: 8px 12px;">
                            <button class="btn btn-success" onclick="applyAndVisualize()">
                                ‚úì Apply Spec & Visualize
                            </button>
                            <span style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 8px;">
                                Prolog populated in editor
                            </span>
                        </div>`;
                    }
                } else {
                    messages.innerHTML += `<div class="message assistant">
                        <div class="message-label">Error</div>
                        ${data.error}
                    </div>`;
                }
            } catch (err) {
                document.getElementById(loadingId)?.remove();
                messages.innerHTML += `<div class="message assistant">
                    <div class="message-label">Error</div>
                    ${err.message}
                </div>`;
            }
            
            messages.scrollTop = messages.scrollHeight;
        }
        
        async function applyAndVisualize() {
            await applySpec();
            switchTab('viz');
            visualize('statemachine');
        }
        
        function clearChat() {
            document.getElementById('chatMessages').innerHTML = `<div class="message assistant">
                <div class="message-label">Turducken</div>
                Describe the system you want to model, and I'll generate a Prolog specification.
            </div>`;
        }
        
        async function visualize(type) {
            const output = document.getElementById('vizOutput');
            output.innerHTML = '<div class="loading"></div>';
            
            try {
                // Pie and Line show message traffic (from message/4 facts)
                if (type === 'pie' || type === 'line') {
                    const resp = await fetch('/api/visualize?type=sequence');
                    const data = await resp.json();
                    const messages = (data.sequence && data.sequence.messages) ? data.sequence.messages : [];
                    
                    if (messages.length === 0) {
                        output.innerHTML = '<div style="color: var(--text-secondary);">No messages to chart. Add message/4 facts.</div>';
                        return;
                    }
                    
                    if (type === 'pie') {
                        const counts = {};
                        messages.forEach(m => {
                            const key = m.from || 'unknown';
                            counts[key] = (counts[key] || 0) + 1;
                        });
                        
                        const slices = Object.entries(counts)
                            .map(([label, value]) => `    "${label}" : ${value}`)
                            .join('\n');
                        
                        output.innerHTML = `<pre class="mermaid">pie title Messages By Sender\n${slices}</pre>`;
                        await mermaid.run();
                        return;
                    } else if (type === 'line') {
                        const ordered = messages.map((m, idx) => ({
                            seq: (typeof m.seq === 'number' && !Number.isNaN(m.seq)) ? m.seq : idx + 1,
                            from: m.from || 'unknown'
                        })).sort((a, b) => a.seq - b.seq);
                        
                        const senders = new Set();
                        ordered.forEach(m => senders.add(m.from));
                        
                        const runningCounts = {};
                        const cumulativeBySender = new Map();
                        for (const sender of senders) {
                            runningCounts[sender] = 0;
                            cumulativeBySender.set(sender, []);
                        }
                        
                        const xValues = [];
                        ordered.forEach(evt => {
                            runningCounts[evt.from]++;
                            xValues.push(evt.seq);
                            
                            for (const [sender, arr] of cumulativeBySender) {
                                arr.push(runningCounts[sender]);
                            }
                        });
                        
                        if (xValues.length === 0) {
                            output.innerHTML = '<div style="color: var(--text-secondary);">No message data.</div>';
                            return;
                        }
                        
                        const maxPoints = 200;
                        let sampledX = xValues;
                        let sampledSeries = cumulativeBySender;
                        
                        if (xValues.length > maxPoints) {
                            const stride = Math.ceil(xValues.length / maxPoints);
                            const sampleIdx = [];
                            for (let i = 0; i < xValues.length; i += stride) {
                                sampleIdx.push(i);
                            }
                            
                            sampledX = sampleIdx.map(i => xValues[i]);
                            sampledSeries = new Map();
                            for (const [sender, values] of cumulativeBySender) {
                                sampledSeries.set(sender, sampleIdx.map(i => values[i]));
                            }
                        }
                        
                        const maxY = Math.max(...Object.values(runningCounts)) + 2;
                        const xAxis = sampledX.map(x => `"${x}"`).join(', ');
                        
                        let code = `xychart-beta
    title "Messages Over Sequence"
    x-axis "Seq" [${xAxis}]
    y-axis "Count" 0 --> ${maxY}`;
                        
                        for (const [sender, values] of sampledSeries) {
                            code += `\n    line [${values.join(', ')}]`;
                        }
                        
                        const series = Array.from(sampledSeries.keys()).map(name => ({ name }));
                        const legendHtml = generateLineLegend({ series });
                        output.innerHTML = `<pre class="mermaid">${code}</pre>${legendHtml}`;
                        try {
                            await mermaid.run();
                        } catch (mermaidErr) {
                            console.error('Mermaid error:', mermaidErr);
                            output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem;">${code}</pre>`;
                        }
                        return;
                    }
                }
                
                // State machine and sequence use Prolog visualization data
                const resp = await fetch(`/api/visualize?type=${type}`);
                const data = await resp.json();
                
                let mermaidCode = '';
                let noDataMessage = '';
                
                switch (type) {
                    case 'statemachine':
                        if (data.stateMachine && data.stateMachine.transitions) {
                            const actorMachines = groupTransitionsByActor(data.stateMachine);
                            if (Object.keys(actorMachines).length > 1) {
                                output.innerHTML = generateActorPanes(actorMachines);
                                await mermaid.run();
                                return;
                            }
                        }
                        mermaidCode = generateStateMachineMermaid(data.stateMachine);
                        break;
                    case 'sequence':
                        mermaidCode = generateSequenceMermaid(data.sequence);
                        if (!mermaidCode) {
                            noDataMessage = 'No sequence messages found. Add lifeline/1 and message/4 facts to your spec.';
                        }
                        break;
                }
                
                if (mermaidCode) {
                    output.innerHTML = `<pre class="mermaid">${mermaidCode}</pre>`;
                    try {
                        await mermaid.run();
                    } catch (mermaidErr) {
                        console.error('Mermaid error:', mermaidErr);
                        output.innerHTML = `<div style="color: var(--accent-red);">Mermaid syntax error</div><pre style="color: var(--text-secondary); font-size: 0.8rem;">${mermaidCode}</pre>`;
                    }
                } else {
                    output.innerHTML = `<div style="color: var(--text-secondary);">${noDataMessage || 'No data to visualize. Load a specification first.'}</div>`;
                }
            } catch (err) {
                output.innerHTML = `<div style="color: var(--accent-red);">Error: ${err.message}</div>`;
            }
        }
        
        function groupTransitionsByActor(sm) {
            const actors = {};
            
            // Dynamically extract prefixes from state names
            // Convention: states are named like "actorname_statename"
            const extractPrefix = (state) => {
                const idx = state.indexOf('_');
                if (idx > 0) {
                    return state.substring(0, idx + 1); // include underscore
                }
                return null;
            };
            
            // Build prefix map from all states we see
            const prefixToActor = new Map();
            
            sm.transitions.forEach(t => {
                [t.from, t.to].forEach(state => {
                    const prefix = extractPrefix(state);
                    if (prefix && !prefixToActor.has(prefix)) {
                        // Actor name is prefix without underscore
                        prefixToActor.set(prefix, prefix.slice(0, -1));
                    }
                });
            });
            
            sm.initial.forEach(s => {
                const prefix = extractPrefix(s);
                if (prefix && !prefixToActor.has(prefix)) {
                    prefixToActor.set(prefix, prefix.slice(0, -1));
                }
            });
            
            // Group transitions by actor
            sm.transitions.forEach(t => {
                const prefix = extractPrefix(t.from) || extractPrefix(t.to);
                if (!prefix) return;
                
                const actor = prefixToActor.get(prefix);
                if (!actor) return;
                
                if (!actors[actor]) {
                    actors[actor] = { transitions: [], initial: [] };
                }
                actors[actor].transitions.push(t);
            });
            
            // Add initial states
            sm.initial.forEach(s => {
                const prefix = extractPrefix(s);
                if (!prefix) return;
                
                const actor = prefixToActor.get(prefix);
                if (!actor) return;
                
                if (!actors[actor]) {
                    actors[actor] = { transitions: [], initial: [] };
                }
                actors[actor].initial.push(s);
            });
            
            return actors;
        }
        
        function generateActorPanes(actorMachines) {
            // Get actors in sorted order (no hardcoded list)
            const actorOrder = Object.keys(actorMachines).sort();
            
            let html = `<div style="
                display: flex; 
                flex-direction: column;
                gap: 16px; 
                overflow: auto;
                max-height: 100%;
                padding: 4px;
            ">`;
            
            for (const actor of actorOrder) {
                const sm = actorMachines[actor];
                if (!sm) continue;
                
                let code = 'stateDiagram-v2\n';
                code += `    direction LR\n`;
                
                sm.initial.forEach(s => {
                    code += `    [*] --> ${s}\n`;
                });
                
                sm.transitions.forEach(t => {
                    // No hardcoded annotations - just show the label
                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                });
                
                html += `
                    <div style="
                        background: var(--bg-tertiary); 
                        padding: 12px; 
                        border-radius: 6px;
                        min-height: 120px;
                        overflow-x: auto;
                    ">
                        <h4 style="margin: 0 0 8px 0; color: var(--accent-blue);">${actor}</h4>
                        <div style="overflow-x: auto; min-width: max-content;">
                            <pre class="mermaid" style="margin: 0;">${code}</pre>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            return html;
        }
        
        function generateStateMachineMermaid(data) {
            if (!data || !data.transitions || data.transitions.length === 0) {
                return null;
            }
            
            let code = 'stateDiagram-v2\n';
            
            if (data.initial && data.initial.length > 0) {
                data.initial.forEach(s => {
                    code += `    [*] --> ${s}\n`;
                });
            }
            
            if (data.transitions) {
                data.transitions.forEach(t => {
                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                });
            }
            
            if (data.accepting && data.accepting.length > 0) {
                data.accepting.forEach(s => {
                    code += `    ${s} --> [*]\n`;
                });
            }
            
            return code;
        }
        
        function generateSequenceMermaid(data) {
            if (!data || !data.messages || data.messages.length === 0) {
                return null;
            }
            
            let code = 'sequenceDiagram\n';
            
            if (data.lifelines) {
                data.lifelines.forEach(l => {
                    code += `    participant ${l}\n`;
                });
            }
            
            if (data.messages) {
                data.messages.forEach(m => {
                    code += `    ${m.from}->>${m.to}: ${m.label}\n`;
                });
            }
            
            return code;
        }
        
        function generatePieMermaid(data) {
            if (!data || !data.slices || data.slices.length === 0) {
                return null;
            }
            
            let code = 'pie title Request Distribution\n';
            data.slices.forEach(s => {
                code += `    "${s.label}" : ${s.value}\n`;
            });
            return code;
        }
        
        function generateLineMermaid(data) {
            if (!data || !data.series || data.series.length === 0) {
                return null;
            }
            
            const allXValues = new Set();
            data.series.forEach(series => {
                if (series.points) {
                    series.points.forEach(p => allXValues.add(p.x));
                }
            });
            
            if (allXValues.size === 0) {
                return null;
            }
            
            const sortedX = [...allXValues].sort((a, b) => a - b);
            const xValues = sortedX.map(x => `"${x}"`).join(', ');
            
            let maxY = 0;
            data.series.forEach(series => {
                if (series.points) {
                    series.points.forEach(p => {
                        if (p.y > maxY) maxY = p.y;
                    });
                }
            });
            maxY += 5;
            
            let code = `xychart-beta
    title "Metrics Over Time"
    x-axis [${xValues}]
    y-axis "Value" 0 --> ${maxY}`;
            
            data.series.forEach(series => {
                if (series.points && series.points.length > 0) {
                    const pointMap = new Map();
                    series.points.forEach(p => pointMap.set(p.x, p.y));
                    const yValues = sortedX.map(x => pointMap.has(x) ? pointMap.get(x) : 0).join(', ');
                    code += `\n    line [${yValues}]`;
                }
            });
            
            return code;
        }
        
        // Generate legend HTML for line chart
        function generateLineLegend(data) {
            if (!data || !data.series || data.series.length === 0) {
                return '';
            }
            
            const colors = ['#58a6ff', '#3fb950', '#f85149', '#d29922', '#a371f7', '#f778ba'];
            
            let html = '<div style="display: flex; flex-wrap: wrap; gap: 16px; margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">';
            data.series.forEach((series, i) => {
                const color = colors[i % colors.length];
                html += `<div style="display: flex; align-items: center; gap: 6px;">
                    <div style="width: 20px; height: 3px; background: ${color};"></div>
                    <span style="color: var(--text-secondary); font-size: 0.85rem;">${series.name}</span>
                </div>`;
            });
            html += '</div>';
            return html;
        }
        
        // Example specifications
        const examples = {
            mutex: `% Mutual Exclusion Protocol
                state(free, [available]).
                state(locked, [busy]).
                
                initial(free).
                
                transition(free, acquire, locked).
                transition(locked, release, free).
                
                prop(free, available).
                prop(locked, busy).
                
                property(no_deadlock, 'Can always release', 'ag(ef(atom(available)))').`,
                
            channel: `% Buffered Channel (CSP style)
                state(empty, [can_send]).
                state(has_one, [can_send, can_recv]).
                state(full, [can_recv]).
                
                initial(empty).
                
                transition(empty, send, has_one).
                transition(has_one, send, full).
                transition(full, recv, has_one).
                transition(has_one, recv, empty).
                
                prop(empty, can_send).
                prop(has_one, can_send).
                prop(has_one, can_recv).
                prop(full, can_recv).
                
                property(liveness, 'Can always send again', 'ag(ef(atom(can_send)))').`,
                
            sequence: `% Request-Response Protocol
                lifeline(client).
                lifeline(server).
                lifeline(database).
                
                message(1, client, server, request).
                message(2, server, database, query).
                message(3, database, server, result).
                message(4, server, client, response).
                
                state(idle, [ready]).
                state(requesting, [busy]).
                state(querying, [busy]).
                state(responding, [busy]).
                
                initial(idle).
                accepting(idle).
                
                transition(idle, request, requesting).
                transition(requesting, query, querying).
                transition(querying, result, responding);
                transition(responding, response, idle).
                
                prop(idle, ready).
                prop(requesting, busy).
                prop(querying, busy).
                prop(responding, busy).
                
                property(completes, 'Requests complete', 'ag(or(not(atom(busy)), af(atom(ready))))').`
                ,
            bread_company: `% Bread Company Operations
                doc(title, 'Bread Company Operations').
                doc(version, '0.1.0').
                doc(author, 'Generated by LLM').
                doc(overview, 'A bread company with production, logistics, retail, and customer demand.').
                doc(description, 'Actors communicate via messages. Production and customer arrivals are probabilistic chance nodes. Pie/line charts should visualize message volume by sender.').
                
                doc(role_factory, 'Factory mixes, kneads, bakes, cools, and bags bread.').
                doc(role_bakers, 'Bakers operate machines, knead dough, and manage oven loads.').
                doc(role_truck, 'Truck loads bagged bread and delivers to the storefront.').
                doc(role_storefront, 'Storefront receives bread, stocks racks, sells to customers, and manages aging inventory.').
                doc(role_customers, 'Customers arrive stochastically and buy bread from the fresh rack.').
                doc(role_charity, 'Charity rack receives bread older than 3 days.').
                doc(role_accounting, 'Accounting tracks wages, revenue, and profitability.').
                
                doc(viz_statemachine, 'State machines show operational modes per actor. Chance states model probabilistic events.').
                doc(viz_sequence, 'Sequence diagram shows a typical day: production -> delivery -> stocking -> customer sales -> accounting updates.').
                doc(viz_pie, 'Pie chart shows message volume by sender (actor).').
                doc(viz_line, 'Line chart shows cumulative messages by sender over sequence order.').
                
                actor(factory).
                actor(bakers).
                actor(truck).
                actor(storefront).
                actor(customers).
                actor(charity).
                actor(accounting).
                
                actor_initial(factory, factory_idle).
                actor_initial(bakers, bakers_idle).
                actor_initial(truck, truck_idle).
                actor_initial(storefront, store_closed).
                actor_initial(customers, customers_idle).
                actor_initial(charity, charity_idle).
                actor_initial(accounting, accounting_break_even).
                
                actor_state(factory, factory_idle, [ready]).
                actor_state(factory, factory_chance_batch, [chance]).
                actor_state(factory, factory_mixing, [in_progress]).
                actor_state(factory, factory_kneading, [in_progress]).
                actor_state(factory, factory_baking, [in_progress]).
                actor_state(factory, factory_cooling, [in_progress]).
                actor_state(factory, factory_bagging, [bagged_stock]).
                actor_state(factory, factory_waiting_truck, [bagged_stock]).
                
                actor_state(bakers, bakers_idle, [available]).
                actor_state(bakers, bakers_running_mixer, [busy]).
                actor_state(bakers, bakers_kneading, [busy]).
                actor_state(bakers, bakers_loading_oven, [busy]).
                actor_state(bakers, bakers_unloading_oven, [busy]).
                
                actor_state(truck, truck_idle, [available]).
                actor_state(truck, truck_loading, [busy]).
                actor_state(truck, truck_in_transit, [busy]).
                actor_state(truck, truck_unloading, [busy]).
                
                actor_state(storefront, store_closed, [closed]).
                actor_state(storefront, store_open, [open]).
                actor_state(storefront, store_stocking, [open]).
                actor_state(storefront, store_fresh_rack_full, [fresh_stock]).
                actor_state(storefront, store_fresh_rack_low, [fresh_stock, low_stock]).
                actor_state(storefront, store_charity_rack, [has_charity_stock]).
                actor_state(storefront, store_rotating_stock, [aging_stock]).
                actor_state(storefront, store_sold_out, [no_stock]).
                
                actor_state(customers, customers_idle, [chance]).
                actor_state(customers, customers_arriving_low, [arriving]).
                actor_state(customers, customers_arriving_high, [arriving]).
                actor_state(customers, customers_buying, [buying]).
                
                actor_state(charity, charity_idle, [ready]).
                actor_state(charity, charity_receiving, [receiving]).
                actor_state(charity, charity_stocked, [has_stock]).
                
                actor_state(accounting, accounting_break_even, [neutral]).
                actor_state(accounting, accounting_profitable, [profitable]).
                actor_state(accounting, accounting_loss, [loss]).
                actor_state(accounting, accounting_payroll, [wages_due]).
                actor_state(accounting, accounting_revenue, [revenue_in]).
                
                actor_transition(factory, factory_idle, start_day, factory_chance_batch).
                actor_transition(factory, factory_chance_batch, batch_low, factory_mixing).
                actor_transition(factory, factory_chance_batch, batch_high, factory_mixing).
                actor_transition(factory, factory_mixing, mixed, factory_kneading).
                actor_transition(factory, factory_kneading, kneaded, factory_baking).
                actor_transition(factory, factory_baking, baked, factory_cooling).
                actor_transition(factory, factory_cooling, cooled, factory_bagging).
                actor_transition(factory, factory_bagging, bagged, factory_waiting_truck).
                actor_transition(factory, factory_waiting_truck, loaded, factory_idle).
                
                actor_transition(bakers, bakers_idle, run_mixer, bakers_running_mixer).
                actor_transition(bakers, bakers_running_mixer, dough_ready, bakers_kneading).
                actor_transition(bakers, bakers_kneading, dough_kneaded, bakers_loading_oven).
                actor_transition(bakers, bakers_loading_oven, oven_loaded, bakers_unloading_oven).
                actor_transition(bakers, bakers_unloading_oven, oven_unloaded, bakers_idle).
                
                actor_transition(truck, truck_idle, arrive_factory, truck_loading).
                actor_transition(truck, truck_loading, loaded_truck, truck_in_transit).
                actor_transition(truck, truck_in_transit, arrive_store, truck_unloading).
                actor_transition(truck, truck_unloading, unloaded_store, truck_idle).
                
                actor_transition(storefront, store_closed, open_store, store_open).
                actor_transition(storefront, store_open, receive_delivery, store_stocking).
                actor_transition(storefront, store_stocking, racks_full, store_fresh_rack_full).
                actor_transition(storefront, store_fresh_rack_full, sell_bread, store_fresh_rack_low).
                actor_transition(storefront, store_fresh_rack_low, sell_out, store_sold_out).
                actor_transition(storefront, store_fresh_rack_low, restock, store_fresh_rack_full).
                actor_transition(storefront, store_fresh_rack_full, rotate_stock, store_rotating_stock).
                actor_transition(storefront, store_rotating_stock, moved_to_charity, store_charity_rack).
                actor_transition(storefront, store_charity_rack, charity_rack_set, store_open).
                actor_transition(storefront, store_sold_out, close_store, store_closed).
                
                actor_transition(customers, customers_idle, chance_arrival, customers_arriving_low).
                actor_transition(customers, customers_idle, chance_arrival_peak, customers_arriving_high).
                actor_transition(customers, customers_arriving_low, browse, customers_buying).
                actor_transition(customers, customers_arriving_high, rush, customers_buying).
                actor_transition(customers, customers_buying, checkout, customers_idle).
                
                actor_transition(charity, charity_idle, notify_pickup, charity_receiving).
                actor_transition(charity, charity_receiving, stocked, charity_stocked).
                actor_transition(charity, charity_stocked, clear_rack, charity_idle).
                
                actor_transition(accounting, accounting_break_even, record_wages, accounting_payroll).
                actor_transition(accounting, accounting_payroll, wages_paid, accounting_loss).
                actor_transition(accounting, accounting_loss, record_sales, accounting_revenue).
                actor_transition(accounting, accounting_revenue, profit_high, accounting_profitable).
                actor_transition(accounting, accounting_revenue, profit_low, accounting_break_even).
                actor_transition(accounting, accounting_profitable, record_wages, accounting_payroll).
                
                msg_annotation(start_day, send, bakers).
                msg_annotation(mixed, send, bakers).
                msg_annotation(kneaded, send, bakers).
                msg_annotation(baked, send, bakers).
                msg_annotation(cooled, send, bakers).
                msg_annotation(bagged, send, truck).
                msg_annotation(loaded_truck, send, truck).
                msg_annotation(arrive_store, send, storefront).
                msg_annotation(receive_delivery, recv, truck).
                msg_annotation(sell_bread, recv, customers).
                msg_annotation(checkout, send, accounting).
                msg_annotation(moved_to_charity, send, charity).
                
                lifeline(factory).
                lifeline(bakers).
                lifeline(truck).
                lifeline(storefront).
                lifeline(customers).
                lifeline(charity).
                lifeline(accounting).
                
                message(1, factory, bakers, start_day).
                message(2, bakers, factory, mixed).
                message(3, bakers, factory, kneaded).
                message(4, bakers, factory, baked).
                message(5, bakers, factory, cooled).
                message(6, factory, truck, bagged).
                message(7, truck, storefront, deliver_bread).
                message(8, storefront, truck, receive_delivery).
                message(9, storefront, storefront, stock_fresh_rack).
                message(10, customers, storefront, arrive).
                message(11, storefront, customers, offer_bread).
                message(12, customers, storefront, purchase_8).
                message(13, storefront, accounting, record_sale).
                message(14, storefront, charity, move_old_stock).
                message(15, charity, storefront, pickup_confirm).
                message(16, accounting, storefront, revenue_ok).
                
                prop(State, Prop) :- actor_state(_, State, Props), member(Prop, Props).
                initial(S) :- actor_initial(_, S).
                transition(From, Label, To) :- actor_transition(_, From, Label, To).
                
                property(profitable_eventually, 'Business can reach profitability', 'ag(ef(atom(profitable)))').
                property(avoid_permanent_stockout, 'Fresh rack not permanently empty', 'ag(ef(atom(fresh_stock)))').
                property(charity_receives_old_stock, 'Old stock eventually moved to charity', 'ag(ef(atom(has_charity_stock)))').
                property(wages_recorded, 'Payroll is eventually recorded', 'ag(ef(atom(wages_due)))').
                property(open_store_reachable, 'Store can open from initial conditions', 'ag(ef(atom(open)))').`
        };
        
        function loadExample(name) {
            document.getElementById('specEditor').value = examples[name];
            switchTab('spec');
        }
        
        const MAX_AUTO_FIX_RETRIES = 3;
        
        async function loadProperties() {
            try {
                const resp = await fetch('/api/properties');
                const data = await resp.json();
                
                const listDiv = document.getElementById('propertyList');
                if (data.success && data.properties && data.properties.length > 0) {
                    listDiv.innerHTML = data.properties.map(p => {
                        let statusIcon = '';
                        let statusColor = '';
                        if (p.error) {
                            statusIcon = '‚ö†Ô∏è';
                            statusColor = 'var(--accent-yellow)';
                        } else if (p.satisfied === true) {
                            statusIcon = '‚úì';
                            statusColor = 'var(--accent-green)';
                        } else if (p.satisfied === false) {
                            statusIcon = '‚úó';
                            statusColor = 'var(--accent-red)';
                        }
                        
                        return `
                        <div style="margin-bottom: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="color: ${statusColor}; font-size: 1.2rem;">${statusIcon}</span>
                                <strong style="color: var(--accent-blue);">${p.name}</strong>
                            </div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-left: 28px;">${p.description}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-purple); margin-left: 28px; font-family: monospace;">${p.formula}</div>
                            ${p.error ? `<div style="font-size: 0.8rem; color: var(--accent-red); margin-left: 28px;">Error: ${p.error}</div>` : ''}
                        </div>
                    `}).join('');
                } else {
                    listDiv.innerHTML = '<div style="color: var(--text-secondary);">No properties defined in spec</div>';
                }
            } catch (err) {
                console.error('Error loading properties:', err);
            }
        }
        
        async function checkNamedProperty(name, formula) {
            document.getElementById('propertyInput').value = formula;
            await checkProperty();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function formatResponse(text) {
            // Simple markdown-like formatting
            return escapeHtml(text)
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }
        
        // Initialize on page load
        loadProperties();
        loadDocs();
        
        window.addEventListener('load', () => {
            document.getElementById('vizOutput').innerHTML = '<div style="color: var(--text-secondary);">Select a visualization type above, or load a spec first.</div>';
        });
        
        // Keyboard shortcuts
        document.getElementById('queryInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                runQuery();
            }
        });
        
        document.getElementById('propertyInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkProperty();
            }
        });
        
        document.getElementById('chatInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                sendChat();
            }
        });
        
        function setStatus(message, type = 'info') {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (type === 'error') {
                indicator.classList.add('error');
            } else if (type === 'success') {
                indicator.classList.add('success');
            }
        }
        
        function switchProvider() {
            const provider = document.getElementById('providerSelect').value;
            fetch('/api/provider', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ provider })
            }).then(() => {
                setStatus(`Switched to ${provider}`, 'success');
            }).catch(err => {
                setStatus(`Failed to switch: ${err.message}`, 'error');
            });
        }
        
        function generateActorStateMachinesMermaid(actors) {
            if (!actors || actors.length === 0) {
                return null;
            }
            
            let code = '';
            actors.forEach((actor, idx) => {
                if (idx > 0) code += '\n\n';
                code += `stateDiagram-v2\n`;
                code += `    direction LR\n`;
                code += `    %% ${actor.actor}\n`;
                
                if (actor.initial) {
                    code += `    [*] --> ${actor.initial}\n`;
                }
                
                actor.transitions.forEach(t => {
                    code += `    ${t.from} --> ${t.to}: ${t.label}\n`;
                });
            });
            
            return code;
        }
        
        // Add this function and call it when spec loads:

        async function loadDocs() {
            try {
                const resp = await fetch('/api/docs');
                const data = await resp.json();
                const actorsResp = await fetch('/api/actors');
                const actorsData = await actorsResp.json();
                
                const container = document.getElementById('docsContent');
                const docs = (data.success && data.docs) ? data.docs : [];
                const actors = (actorsData.success && actorsData.actors) ? actorsData.actors : [];
                const docsByTopic = new Map(docs.map(doc => [doc.topic, doc.content]));
                
                const renderActorCards = (targetId) => {
                    const target = document.getElementById(targetId);
                    if (!target) return;
                    
                    if (actors.length === 0) {
                        target.innerHTML = '<div style="color: var(--text-secondary);">No actors defined. Add actor/1 facts.</div>';
                        return;
                    }
                    
                    let html = '<div style="margin-bottom: 12px;">';
                    html += '<div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Actors</div>';
                    
                    actors.forEach(actor => {
                        const roleKey = `role_${actor}`;
                        const actorKey = `actor_${actor}`;
                        const description = docsByTopic.get(roleKey) || docsByTopic.get(actorKey) || '';
                        const fallback = `Add doc(role_${actor}, '...') to describe intent.`;
                        html += `<div style="margin-bottom: 10px; padding: 8px 10px; background: var(--bg-secondary); border-radius: 4px; border: 1px solid var(--border-color);">`;
                        html += `<div style="color: var(--accent-blue); font-weight: 600; font-size: 0.9rem;">${actor}</div>`;
                        html += `<div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 4px;">${description || fallback}</div>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    target.innerHTML = html;
                };
                
                renderActorCards('actorSummary');
                
                if (docs.length > 0) {
                    // Group docs by category based on topic prefix
                    const sections = {
                        'Overview': [],
                        'Roles': [],
                        'Phases': [],
                        'Safety': [],
                        'Visualizations': [],
                        'Other': []
                    };
                    
                    docs.forEach(doc => {
                        const topic = doc.topic || '';
                        if (topic === 'title' || topic === 'version' || topic === 'author' || topic === 'overview' || topic === 'description') {
                            sections['Overview'].push(doc);
                        } else if (topic.startsWith('role_')) {
                            sections['Roles'].push(doc);
                        } else if (topic.startsWith('phase')) {
                            sections['Phases'].push(doc);
                        } else if (topic.startsWith('safety_')) {
                            sections['Safety'].push(doc);
                        } else if (topic.startsWith('viz_')) {
                            sections['Visualizations'].push(doc);
                        } else {
                            sections['Other'].push(doc);
                        }
                    });
                    
                    let html = '';
                    
                    // Render Overview section specially
                    if (sections['Overview'].length > 0) {
                        const titleDoc = sections['Overview'].find(d => d.topic === 'title');
                        const versionDoc = sections['Overview'].find(d => d.topic === 'version');
                        const overviewDoc = sections['Overview'].find(d => d.topic === 'overview');
                        const descDoc = sections['Overview'].find(d => d.topic === 'description');
                        
                        html += `<div style="margin-bottom: 24px;">`;
                        if (titleDoc) {
                            html += `<h2 style="color: var(--accent-blue); margin: 0;">${titleDoc.content}</h2>`;
                        }
                        if (versionDoc) {
                            html += `<div style="color: var(--text-secondary); font-size: 0.85rem;">Version ${versionDoc.content}</div>`;
                        }
                        if (overviewDoc) {
                            html += `<p style="margin-top: 12px; color: var(--text-primary);">${overviewDoc.content}</p>`;
                        }
                        if (descDoc) {
                            html += `<p style="margin-top: 8px; color: var(--text-secondary);">${descDoc.content}</p>`;
                        }
                        html += `</div>`;
                    }
                    
                    if (actors.length > 0) {
                        html += '<div style="margin-bottom: 20px;">';
                        html += '<h3 style="color: var(--accent-purple); margin: 0 0 8px 0; font-size: 1rem;">Actors</h3>';
                        actors.forEach(actor => {
                            const roleKey = `role_${actor}`;
                            const actorKey = `actor_${actor}`;
                            const description = docsByTopic.get(roleKey) || docsByTopic.get(actorKey) || '';
                            const fallback = `Add doc(role_${actor}, '...') to describe intent.`;
                            html += `<div style="margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 4px;">`;
                            html += `<div style="font-weight: 500; color: var(--accent-blue); font-size: 0.9rem;">${actor}</div>`;
                            html += `<div style="color: var(--text-primary); font-size: 0.85rem; margin-top: 4px;">${description || fallback}</div>`;
                            html += `</div>`;
                        });
                        html += '</div>';
                    }
                    
                    // Render other sections
                    const sectionOrder = ['Roles', 'Phases', 'Safety', 'Visualizations', 'Other'];
                    for (const sectionName of sectionOrder) {
                        const docs = sections[sectionName];
                        if (docs.length === 0) continue;
                        
                        html += `<div style="margin-bottom: 20px;">`;
                        html += `<h3 style="color: var(--accent-purple); margin: 0 0 8px 0; font-size: 1rem;">${sectionName}</h3>`;
                        
                        docs.forEach(doc => {
                            // Clean up topic name for display
                            let displayTopic = doc.topic
                                .replace(/^(role_|phase|safety_|viz_)/, '')
                                .replace(/_/g, ' ')
                                .replace(/\b\w/g, c => c.toUpperCase());
                            
                            html += `<div style="margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 4px;">`;
                            html += `<div style="font-weight: 500; color: var(--accent-blue); font-size: 0.9rem;">${displayTopic}</div>`;
                            html += `<div style="color: var(--text-primary); font-size: 0.85rem; margin-top: 4px;">${doc.content}</div>`;
                            html += `</div>`;
                        });
                        
                        html += `</div>`;
                    }
                    
                    container.innerHTML = html;
                } else {
                    container.innerHTML = '<div style="color: var(--text-secondary);">No documentation in spec. Add doc(topic, content) facts.</div>';
                }
            } catch (err) {
                console.error('Error loading docs:', err);
            }
        }
        
        // Update applySpec to also load docs
        async function applySpec() {
            const source = document.getElementById('specEditor').value;
            try {
                const resp = await fetch('/api/spec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source })
                });
                const data = await resp.json();
                
                if (data.success) {
                    setStatus('Spec applied successfully!', 'success');
                    loadProperties();
                    loadDocs();  // Add this line
                } else {
                    setStatus(`Spec error: ${data.error}`, 'error');
                    console.error('Prolog error:', data.error);
                }
            } catch (err) {
                setStatus(`Failed: ${err.message}`, 'error');
            }
        }
        
        // Also load docs on page load
        // Add after loadProperties() call:
        loadProperties();
        loadDocs();
    </script>
</body>
</html>
